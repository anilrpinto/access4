<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Cross-Platform Crypto Compatibility Test</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { font-family: monospace; padding: 12px; }
  h2 { margin-top: 24px; }
  .panel { border: 1px solid #ccc; padding: 10px; margin-top: 10px; }
  .pass { color: green; }
  .fail { color: red; }
  pre { white-space: pre-wrap; word-break: break-word; }
</style>
<script src="https://apis.google.com/js/api.js"></script>
</head>
<body>

<h1>Crypto Compatibility Test</h1>

<h2>1. Environment Fingerprint</h2>
<div id="env" class="panel"></div>

<h2>2. Deterministic Crypto Test</h2>
<div id="deterministic" class="panel"></div>

<h2>3. Crypto Self-Tests</h2>
<div id="tests" class="panel"></div>

<h2>4. Serialization Round-Trip Test</h2>
<div id="serialize" class="panel"></div>

<h2>5. Stateful Encrypt / Decrypt Test</h2>
<div class="panel">
  <button id="encryptBtn">Encrypt & Store</button>
  <button id="decryptBtn">Decrypt Stored</button>
  <div id="stateful"></div>
</div>

<h2>6. Google Drive Binary Round-Trip Test</h2>
<div class="panel">
  <button id="driveUploadBtn">Upload Test Payload</button>
  <button id="driveDownloadBtn">Download & Verify</button>
  <div id="drive"></div>
</div>

<script>
let STORED = { salt: null, iv: null, ciphertext: null };
let DRIVE_TEST = { fileId: null, original: null };
const enc = new TextEncoder();
const dec = new TextDecoder();
const log = (el, msg) => el.innerHTML += msg + "<br>";

/* ---------------- Environment ---------------- */
function fingerprint() {
  const envEl = document.getElementById("env");
  const ua = navigator.userAgent;
  const isIOS = /iPad|iPhone|iPod/.test(ua);
  const iosVersion = isIOS ? (ua.match(/OS (\d+)_?(\d+)?/) || []).slice(1).join(".") : "N/A";
  log(envEl, `User Agent: ${ua}`);
  log(envEl, `Platform: ${isIOS ? "iOS " + iosVersion : navigator.platform}`);
  log(envEl, `WebCrypto: ${!!window.crypto && !!crypto.subtle}`);
}

/* ---------------- Helpers ---------------- */
function toBase64(buf) { return btoa(String.fromCharCode(...new Uint8Array(buf))); }
function fromBase64(b64) { return Uint8Array.from(atob(b64), c => c.charCodeAt(0)); }
async function sha256(buf) { return crypto.subtle.digest("SHA-256", buf); }
async function deriveKey(password, salt) {
  const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), "PBKDF2", false, ["deriveKey"]);
  return crypto.subtle.deriveKey(
    { name: "PBKDF2", salt: enc.encode(salt), iterations: 100000, hash: "SHA-256" },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    true,
    ["encrypt", "decrypt"]
  );
}

/* ---------------- Deterministic Test ---------------- */
async function deterministicTest() {
  const detEl = document.getElementById("deterministic");
  const password = "correct horse battery staple";
  const salt = "fixed-test-salt";
  const iv = new Uint8Array(12).fill(7);
  const plaintext = "GIS:POINT(-122.4194 37.7749)";
  try {
    const key = await deriveKey(password, salt);
    const rawKey = await crypto.subtle.exportKey("raw", key);
    const keyHash = toBase64(await sha256(rawKey));

    const cipherBuf = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, enc.encode(plaintext));
    const decryptedBuf = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, cipherBuf);
    const decrypted = dec.decode(decryptedBuf);

    log(detEl, `Key SHA-256: ${keyHash}`);
    log(detEl, `Ciphertext: ${toBase64(cipherBuf)}`);
    log(detEl, `Decrypted: ${decrypted}`);
    log(detEl, decrypted === plaintext
      ? `<span class="pass">PASS</span>`
      : `<span class="fail">FAIL</span>`
    );
  } catch (e) { log(detEl, `<span class="fail">ERROR: ${e.message}</span>`); }
}

/* ---------------- Serialization Test ---------------- */
async function serializationTest() {
  const el = document.getElementById("serialize");
  const password = "correct horse battery staple";
  const salt = "fixed-test-salt";
  const iv = new Uint8Array(12).fill(9);
  const plaintext = "GIS:POLYGON((-122.5 37.7,-122.3 37.7,-122.3 37.8,-122.5 37.8,-122.5 37.7))";
  try {
    const key = await deriveKey(password, salt);
    const cipherBuf = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, enc.encode(plaintext));
    const payload = { salt, iv: toBase64(iv.buffer), ciphertext: toBase64(cipherBuf) };
    const parsed = JSON.parse(JSON.stringify(payload));
    const iv2 = fromBase64(parsed.iv);
    const cipher2 = fromBase64(parsed.ciphertext);
    const decryptedBuf = await crypto.subtle.decrypt({ name: "AES-GCM", iv: iv2 }, key, cipher2);
    const decrypted = dec.decode(decryptedBuf);
    log(el, `IV length before: ${iv.length}, after: ${iv2.length}`);
    log(el, `Cipher length before: ${cipherBuf.byteLength}, after: ${cipher2.length}`);
    log(el, `Decrypted: ${decrypted}`);
    log(el, decrypted === plaintext
      ? `<span class="pass">PASS (serialization intact)</span>`
      : `<span class="fail">FAIL (data mismatch)</span>`
    );
  } catch (e) { log(el, `<span class="fail">ERROR: ${e.message}</span>`); }
}

/* ---------------- Stateful Test ---------------- */
function setupStatefulTest() {
  const el = document.getElementById("stateful");
  const password = "correct horse battery staple";
  const salt = "fixed-test-salt";
  const plaintext = "GIS:STATEFUL:POINT(-73.9857 40.7484)";
  document.getElementById("encryptBtn").onclick = async () => {
    el.innerHTML = "";
    try {
      const key = await deriveKey(password, salt);
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const cipherBuf = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, enc.encode(plaintext));
      STORED.salt = salt; STORED.iv = iv; STORED.ciphertext = cipherBuf;
      log(el, `Stored IV length: ${iv.length}, cipher length: ${cipherBuf.byteLength}`);
      log(el, `<span class="pass">ENCRYPT OK</span>`);
    } catch (e) { log(el, `<span class="fail">ENCRYPT ERROR: ${e.message}</span>`); }
  };
  document.getElementById("decryptBtn").onclick = async () => {
    try {
      if (!STORED.ciphertext) { log(el, `<span class="fail">Nothing stored yet</span>`); return; }
      const key = await deriveKey(password, STORED.salt);
      const decryptedBuf = await crypto.subtle.decrypt({ name: "AES-GCM", iv: STORED.iv }, key, STORED.ciphertext);
      const decrypted = dec.decode(decryptedBuf);
      log(el, `Decrypted: ${decrypted}`);
      log(el, decrypted === plaintext
        ? `<span class="pass">DECRYPT PASS</span>`
        : `<span class="fail">DECRYPT FAIL</span>`
      );
    } catch (e) { log(el, `<span class="fail">DECRYPT ERROR: ${e.message}</span>`); }
  };
}

/* ---------------- Self Tests ---------------- */
async function selfTests() {
  const testEl = document.getElementById("tests");
  const results = [];
  async function test(name, fn) { try { await fn(); results.push(`✓ ${name}`); } catch(e){ results.push(`✗ ${name}: ${e.message}`); } }
  await test("TextEncoder UTF-8", () => { const b = enc.encode("✓"); if(b.length!==3) throw new Error("UTF-8 encoding mismatch"); });
  await test("Base64 Round-Trip", () => { const buf=new Uint8Array([1,2,3,4,5]).buffer; const b64=toBase64(buf); const out=fromBase64(b64); if(out.length!==5||out[4]!==5) throw new Error("Base64 corruption"); });
  await test("PBKDF2 Derive", async()=>{await deriveKey("a","b");});
  await test("AES-GCM Encrypt/Decrypt", async()=>{ const key=await deriveKey("x","y"); const iv=crypto.getRandomValues(new Uint8Array(12)); const data=enc.encode("test"); const c=await crypto.subtle.encrypt({name:"AES-GCM",iv},key,data); const p=await crypto.subtle.decrypt({name:"AES-GCM",iv},key,c); if(dec.decode(p)!=="test") throw new Error("Mismatch"); });
  for(const r of results) log(testEl, r.startsWith("✓")?`<span class="pass">${r}</span>`:`<span class="fail">${r}</span>`);
}

/* ------------------------- DRIVE TESTS ------------------------ */
const CLIENT_ID = "738922366916-ppn1c24mp9qamr6pdmjqss3cqjmvqljv.apps.googleusercontent.com";
const API_KEY = ""; 
const SCOPES = "https://www.googleapis.com/auth/drive.file";

async function ensureDriveReady() {
  return new Promise((resolve, reject) => {
    gapi.load("client:auth2", async () => {
      try {
        await gapi.client.init({ apiKey: API_KEY, clientId: CLIENT_ID, discoveryDocs:["https://www.googleapis.com/discovery/v3/apis/drive/v3/rest"], scope: SCOPES });
        const GoogleAuth = gapi.auth2.getAuthInstance();
        if (!GoogleAuth.isSignedIn.get()) await GoogleAuth.signIn();
        const tokenObj = gapi.auth.getToken();
        if(!tokenObj || !tokenObj.access_token) throw new Error("No OAuth token available");
        log(document.getElementById("drive"), `<span class="pass">Google Auth Successful</span>`);
        console.log("OAuth token ready:", tokenObj.access_token);
        resolve();
      } catch(e) { reject(e); }
    });
  });
}

function buildDriveTestPayload() { const buf=new Uint8Array(1024); for(let i=0;i<buf.length;i++) buf[i]=i%256; return buf; }

async function driveUploadTest() {
  const el = document.getElementById("drive"); el.innerHTML += "<br>";
  try{
    const payload = buildDriveTestPayload(); DRIVE_TEST.original = payload;
    const blob = new Blob([payload],{type:"application/octet-stream"});
    const metadata = {name:"crypto-drive-roundtrip.bin", mimeType:"application/octet-stream"};
    const form = new FormData();
    form.append("metadata", new Blob([JSON.stringify(metadata)],{type:"application/json"}));
    form.append("file", blob);
    const token = gapi.auth.getToken().access_token;
    const res = await fetch("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart",{method:"POST", headers:{ "Authorization": "Bearer "+token }, body:form});
    if(!res.ok){ const text=await res.text(); throw new Error(`HTTP ${res.status}: ${text}`); }
    const json = await res.json(); DRIVE_TEST.fileId=json.id;
    log(el, `Uploaded fileId: ${json.id}`); log(el, `<span class="pass">UPLOAD OK</span>`);
  } catch(e){ log(el, `<span class="fail">UPLOAD ERROR: ${e?.message || JSON.stringify(e)}</span>`); }
}

async function driveDownloadTest() {
  const el = document.getElementById("drive"); el.innerHTML += "<br>";
  try{
    if(!DRIVE_TEST.fileId){ log(el, `<span class="fail">No file uploaded yet</span>`); return; }
    const token = gapi.auth.getToken().access_token;
    const res = await fetch(`https://www.googleapis.com/drive/v3/files/${DRIVE_TEST.fileId}?alt=media`,{headers:{ "Authorization":"Bearer "+token }});
    if(!res.ok){ const text=await res.text(); throw new Error(`HTTP ${res.status}: ${text}`); }
    const buf = new Uint8Array(await res.arrayBuffer());
    log(el, `Original length: ${DRIVE_TEST.original.length}`); log(el, `Downloaded length: ${buf.length}`);
    if(buf.length !== DRIVE_TEST.original.length) throw new Error("Length mismatch");
    for(let i=0;i<buf.length;i++) if(buf[i]!==DRIVE_TEST.original[i]) throw new Error(`Byte mismatch at offset ${i}`);
    log(el, `<span class="pass">BYTE-FOR-BYTE MATCH</span>`);
  } catch(e){ log(el, `<span class="fail">DOWNLOAD ERROR: ${e?.message || JSON.stringify(e)}</span>`); }
}

/* ---------------- Wire Buttons ---------------- */
gapi.load("client:auth2", () => {
  document.getElementById("driveUploadBtn").onclick = async () => {
    const btn = document.getElementById("driveUploadBtn");
    btn.disabled = true;
    try { await ensureDriveReady(); await driveUploadTest(); }
    catch(e){ log(document.getElementById("drive"), `<span class="fail">UPLOAD ERROR: ${e?.message || JSON.stringify(e)}</span>`); }
    finally{ btn.disabled = false; }
  };
  document.getElementById("driveDownloadBtn").onclick = async () => {
    const btn = document.getElementById("driveDownloadBtn");
    btn.disabled = true;
    try { await ensureDriveReady(); await driveDownloadTest(); }
    catch(e){ log(document.getElementById("drive"), `<span class="fail">DOWNLOAD ERROR: ${e?.message || JSON.stringify(e)}</span>`); }
    finally{ btn.disabled = false; }
  };
});

/* ---------------- Run Crypto Tests ---------------- */
(async ()=>{
  fingerprint();
  await deterministicTest();
  await serializationTest();
  await selfTests();
  setupStatefulTest();
})();
</script>

</body>
</html>
