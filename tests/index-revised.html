<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Signal-Style Google Drive Encryption Demo Ver: 5 (Patched)</title>
<style>
body { font-family: sans-serif; max-width: 800px; margin: auto; }
textarea, input { width: 100%; margin: 6px 0; }
button { margin: 6px 0; }
pre { background: #f4f4f4; padding: 10px; overflow-x: auto; }
#userEmail { font-weight: bold; }
.step { margin-left: 10px; }
</style>
<script src="https://accounts.google.com/gsi/client" async defer onload="initGIS()"></script>
</head>

<body>
<h2>Ver: 5 (Patched)</h2>

<div>
  Signed in as: <span id="userEmail">Not signed in</span>
  <button id="signinBtn">Sign in with Google</button>
  <button id="logoutBtn" disabled>Logout</button>
</div>

<label>Password (used to protect private key)</label>
<input id="password" type="password">

<label>Plaintext to encrypt</label>
<textarea id="plaintext">Hello Google Drive ??</textarea>

<button id="encryptUploadBtn">Encrypt & Upload</button>

<hr>

<label>Google Drive File ID to Download</label>
<input id="fileId">

<button id="downloadDecryptBtn">Download & Decrypt</button>

<h3>Output</h3>
<pre id="output"></pre>

<script>
const encoder = new TextEncoder();
const decoder = new TextDecoder();
let accessToken = null;
let tokenClient = null;
let userEmail = null;

// ------------------ Logging ------------------
function log(msg) { document.getElementById("output").textContent += msg + "\n"; }
async function logStep(stepName, fn) {
  const start = performance.now();
  log(`[${stepName}] START`);
  try {
    const result = await fn();
    const duration = Math.round(performance.now() - start);
    log(`[${stepName}] END (${duration} ms)`);
    return result;
  } catch (e) {
    const duration = Math.round(performance.now() - start);
    log(`[${stepName}] FAILED (${duration} ms): ${e}`);
    throw e;
  }
}

// ------------------ Base64 Helpers ------------------
function bufToBase64(buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
}
function base64ToBuf(base64) {
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
  return bytes.buffer;
}

// ------------------ Google Identity Services ------------------
function initGIS() {
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: "738922366916-ppn1c24mp9qamr6pdmjqss3cqjmvqljv.apps.googleusercontent.com",
    scope: "https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.email",
    callback: async (resp) => {
      accessToken = resp.access_token;
      await fetchUserEmail();
      document.getElementById("signinBtn").disabled = true;
      document.getElementById("logoutBtn").disabled = false;
      log("Signed in successfully.");
    }
  });

  // Safe wiring after tokenClient exists
  document.getElementById("signinBtn").onclick = () => tokenClient.requestAccessToken({ prompt: "consent" });
  document.getElementById("logoutBtn").onclick = logout;
}

// ------------------ Fetch User Email ------------------
async function fetchUserEmail() {
  const res = await fetch("https://www.googleapis.com/oauth2/v3/userinfo", { headers: { Authorization: `Bearer ${accessToken}` } });
  const data = await res.json();
  userEmail = data.email;
  document.getElementById("userEmail").textContent = userEmail;
  log(`[fetchUserEmail] Retrieved: ${userEmail}`);
}

// ------------------ Logout ------------------
function logout() {
  accessToken = null;
  userEmail = null;
  localStorage.clear();
  document.getElementById("userEmail").textContent = "Not signed in";
  document.getElementById("signinBtn").disabled = false;
  document.getElementById("logoutBtn").disabled = true;
  log("Logged out and identity cleared.");
}

// ------------------ Crypto Utilities ------------------
async function deriveKey(password, salt) {
  return logStep("Derive AES key from password", async () => {
    const baseKey = await crypto.subtle.importKey("raw", encoder.encode(password), "PBKDF2", false, ["deriveKey"]);
    return crypto.subtle.deriveKey(
      { name:"PBKDF2", salt: new Uint8Array(salt), iterations:250000, hash:"SHA-256" },
      baseKey,
      { name:"AES-GCM", length:256 },
      false,
      ["encrypt","decrypt"]
    );
  });
}

// ------------------ Identity Management ------------------
async function createIdentity(password) {
  return logStep("Create RSA identity keypair", async () => {
    const keyPair = await crypto.subtle.generateKey(
      { name:"RSA-OAEP", modulusLength:2048, publicExponent:new Uint8Array([1,0,1]), hash:"SHA-256" },
      true,
      ["encrypt","decrypt"]
    );

    const pkcs8 = await crypto.subtle.exportKey("pkcs8", keyPair.privateKey);
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const aesKey = await deriveKey(password, salt);
    const encrypted = await crypto.subtle.encrypt({ name:"AES-GCM", iv }, aesKey, pkcs8);

    localStorage.setItem("identity", JSON.stringify({ salt: bufToBase64(salt), iv: bufToBase64(iv), encrypted: bufToBase64(encrypted) }));
    localStorage.setItem("publicKey", bufToBase64(await crypto.subtle.exportKey("spki", keyPair.publicKey)));
    return keyPair;
  });
}

async function loadPrivateKey(password) {
  return logStep("Load and decrypt private key", async () => {
    const stored = JSON.parse(localStorage.getItem("identity"));
    if (!stored || !stored.encrypted) throw new Error("No identity in localStorage");
    const salt = new Uint8Array(base64ToBuf(stored.salt));
    const iv = new Uint8Array(base64ToBuf(stored.iv));
    const encrypted = base64ToBuf(stored.encrypted);
    const aesKey = await deriveKey(password, salt);
    const pkcs8 = await crypto.subtle.decrypt({ name:"AES-GCM", iv }, aesKey, encrypted);
    return crypto.subtle.importKey("pkcs8", pkcs8, { name:"RSA-OAEP", hash:"SHA-256" }, false, ["decrypt"]);
  });
}

async function loadPublicKey() {
  return logStep("Load RSA public key", async () => {
    const stored = localStorage.getItem("publicKey");
    if (!stored) throw new Error("No public key in localStorage");
    return crypto.subtle.importKey("spki", base64ToBuf(stored), { name:"RSA-OAEP", hash:"SHA-256" }, false, ["encrypt"]);
  });
}

// ------------------ Encrypt & Upload ------------------
document.getElementById("encryptUploadBtn").onclick = async () => {
  if (!accessToken) return alert("Sign in first");
  document.getElementById("output").textContent = "";

  const password = document.getElementById("password").value;
  const text = document.getElementById("plaintext").value;

  if (!localStorage.getItem("identity")) await createIdentity(password);

  const publicKey = await loadPublicKey();
  const fileKey = await logStep("Generate AES file key", async () => crypto.subtle.generateKey({ name:"AES-GCM", length:256 }, true, ["encrypt","decrypt"]));
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ciphertext = await logStep("AES-GCM encrypt plaintext", async () => crypto.subtle.encrypt({ name:"AES-GCM", iv }, fileKey, encoder.encode(text)));
  const rawFileKey = await crypto.subtle.exportKey("raw", fileKey);
  const wrappedKey = await logStep("RSA wrap AES key", async () => crypto.subtle.encrypt({ name:"RSA-OAEP" }, publicKey, rawFileKey));

  const envelope = { iv: bufToBase64(iv), wrappedKey: bufToBase64(wrappedKey), ciphertext: bufToBase64(ciphertext) };
  const form = new FormData();
  form.append("metadata", new Blob([JSON.stringify({ name: "encrypted-envelope.json" })], { type: "application/json" }));
  form.append("file", new Blob([JSON.stringify(envelope)], { type: "application/json" }));

  await logStep("Upload to Google Drive", async () => {
    const res = await fetch("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart", { method:"POST", headers:{ Authorization:`Bearer ${accessToken}` }, body:form });
    const json = await res.json();
    if (!json.id) throw new Error("Upload failed");
    log("Uploaded File ID: " + json.id);
  });
};

// ------------------ Download & Decrypt ------------------
document.getElementById("downloadDecryptBtn").onclick = async () => {
  if (!accessToken) { alert("Sign in first"); return; }
  document.getElementById("output").textContent = "";

  const password = document.getElementById("password").value;
  const fileId = document.getElementById("fileId").value;
  if (!fileId) { alert("Enter File ID!"); return; }

  try {
    const envelope = await logStep("Fetch encrypted file from Google Drive", async () => {
      const res = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, { headers:{ Authorization:`Bearer ${accessToken}` } });
      if (!res.ok) throw new Error("Download failed: " + await res.text());
      return await res.json();
    });

    if (!envelope.iv || !envelope.wrappedKey || !envelope.ciphertext) throw new Error("Envelope missing fields");

    const privateKey = await loadPrivateKey(password);
    const iv = new Uint8Array(base64ToBuf(envelope.iv));
    const ciphertext = base64ToBuf(envelope.ciphertext);
    const wrappedKey = base64ToBuf(envelope.wrappedKey);

    const rawFileKey = await logStep("RSA unwrap AES key", async () => crypto.subtle.decrypt({ name:"RSA-OAEP" }, privateKey, wrappedKey));
    const fileKey = await logStep("Import AES key for decryption", async () => crypto.subtle.importKey("raw", rawFileKey, { name:"AES-GCM", length:256 }, false, ["decrypt"]));
    const plaintextBuf = await logStep("AES-GCM decrypt ciphertext", async () => crypto.subtle.decrypt({ name:"AES-GCM", iv }, fileKey, ciphertext));

    const plaintext = decoder.decode(plaintextBuf);
    log("Decrypted text:\n" + plaintext);

  } catch (e) {
    log("Decryption error: " + e);
  }
};

// ------------------ Optional silent token refresh ------------------
setInterval(() => { if (accessToken) tokenClient.requestAccessToken({ prompt: "" }); }, 50*60*1000);

</script>
</body>
</html>