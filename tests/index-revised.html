<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Signal-Style Google Drive Encryption Demo Ver: 5 (Patched + Safety Gate)</title>
<style>
body { font-family: sans-serif; max-width: 800px; margin: auto; }
textarea, input { width: 100%; margin: 6px 0; }
button { margin: 6px 0; }
pre { background: #f4f4f4; padding: 10px; overflow-x: auto; }
#userEmail { font-weight: bold; }
.step { margin-left: 10px; }
</style>
<script src="https://accounts.google.com/gsi/client" async defer onload="initGIS()"></script>
</head>

<body>
<h2>Ver: 5 (Patched + Safety Gate)</h2>

<div>
  Signed in as: <span id="userEmail">Not signed in</span>
  <button id="signinBtn">Sign in with Google</button>
  <button id="logoutBtn" disabled>Logout</button>
</div>

<label>Password (used to protect private key)</label>
<input id="password" type="password">

<label>Plaintext to encrypt</label>
<textarea id="plaintext">Hello Google Drive ??</textarea>

<button id="encryptUploadBtn">Encrypt & Upload</button>

<hr>

<label>Google Drive File ID to Download</label>
<input id="fileId">

<button id="downloadDecryptBtn">Download & Decrypt</button>

<h3>Output</h3>
<pre id="output"></pre>

<script>
const encoder = new TextEncoder();
const decoder = new TextDecoder();
let accessToken = null;
let tokenClient = null;
let userEmail = null;

/* ------------------ Logging ------------------ */
function log(msg) { document.getElementById("output").textContent += msg + "\n"; }
async function logStep(stepName, fn) {
  const start = performance.now();
  log(`[${stepName}] START`);
  try {
    const result = await fn();
    log(`[${stepName}] END (${Math.round(performance.now() - start)} ms)`);
    return result;
  } catch (e) {
    log(`[${stepName}] FAILED (${Math.round(performance.now() - start)} ms): ${e.message || e}`);
    throw e;
  }
}

/* ------------------ Base64 Helpers ------------------ */
function bufToBase64(buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = "";
  for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
}
function base64ToBuf(base64) {
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
  return bytes.buffer;
}

/* ------------------ Crypto Invariant ------------------ */
async function cryptoInvariantCheck() {
  const iv = new Uint8Array(12).fill(1);
  const key = await crypto.subtle.generateKey(
    { name: "AES-GCM", length: 256 },
    true,
    ["encrypt","decrypt"]
  );
  const c = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, encoder.encode("ok"));
  const p = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, c);
  if (decoder.decode(p) !== "ok") throw new Error("Crypto invariant failed");
}

/* ------------------ Google Identity Services ------------------ */
function initGIS() {
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: "738922366916-ppn1c24mp9qamr6pdmjqss3cqjmvqljv.apps.googleusercontent.com",
    scope: "https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.email",
    callback: async (resp) => {
      accessToken = resp.access_token;
      await fetchUserEmail();
      await cryptoInvariantCheck(); // â† safety gate
      document.getElementById("signinBtn").disabled = true;
      document.getElementById("logoutBtn").disabled = false;
      log("Signed in successfully.");
    }
  });

  document.getElementById("signinBtn").onclick =
    () => tokenClient.requestAccessToken({ prompt: "consent" });
  document.getElementById("logoutBtn").onclick = logout;
}

async function fetchUserEmail() {
  const res = await fetch("https://www.googleapis.com/oauth2/v3/userinfo", {
    headers: { Authorization: `Bearer ${accessToken}` }
  });
  const data = await res.json();
  userEmail = data.email;
  document.getElementById("userEmail").textContent = userEmail;
  log(`[fetchUserEmail] ${userEmail}`);
}

function logout() {
  accessToken = null;
  userEmail = null;
  localStorage.clear();
  document.getElementById("userEmail").textContent = "Not signed in";
  document.getElementById("signinBtn").disabled = false;
  document.getElementById("logoutBtn").disabled = true;
  log("Logged out and identity cleared.");
}

/* ------------------ Crypto Utilities ------------------ */
async function deriveKey(password, salt) {
  return logStep("Derive AES key", async () => {
    const baseKey = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
    );
    return crypto.subtle.deriveKey(
      { name: "PBKDF2", salt, iterations: 250000, hash: "SHA-256" },
      baseKey,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt","decrypt"]
    );
  });
}

/* ------------------ Identity ------------------ */
async function createIdentity(password) {
  return logStep("Create identity", async () => {
    const keyPair = await crypto.subtle.generateKey(
      { name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([1,0,1]), hash: "SHA-256" },
      true,
      ["encrypt","decrypt"]
    );
    const pkcs8 = await crypto.subtle.exportKey("pkcs8", keyPair.privateKey);
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const aesKey = await deriveKey(password, salt);
    const encrypted = await crypto.subtle.encrypt({ name:"AES-GCM", iv }, aesKey, pkcs8);

    localStorage.setItem("identity", JSON.stringify({
      version: 1,
      salt: bufToBase64(salt),
      iv: bufToBase64(iv),
      encrypted: bufToBase64(encrypted)
    }));
    localStorage.setItem("publicKey", bufToBase64(await crypto.subtle.exportKey("spki", keyPair.publicKey)));
  });
}

async function loadPrivateKey(password) {
  return logStep("Load private key", async () => {
    const stored = JSON.parse(localStorage.getItem("identity"));
    if (!stored || stored.version !== 1) throw new Error("Unsupported or missing identity");

    const salt = new Uint8Array(base64ToBuf(stored.salt));
    const iv = new Uint8Array(base64ToBuf(stored.iv));
    const encrypted = base64ToBuf(stored.encrypted);
    const aesKey = await deriveKey(password, salt);
    try {
      const pkcs8 = await crypto.subtle.decrypt({ name:"AES-GCM", iv }, aesKey, encrypted);
      return crypto.subtle.importKey("pkcs8", pkcs8, { name:"RSA-OAEP", hash:"SHA-256" }, false, ["decrypt"]);
    } catch(e) {
      if (e.name === "OperationError") throw new Error("Incorrect password or corrupted identity");
      throw e;
    }
  });
}

async function loadPublicKey() {
  return logStep("Load public key", async () => {
    const stored = localStorage.getItem("publicKey");
    if (!stored) throw new Error("No public key");
    return crypto.subtle.importKey("spki", base64ToBuf(stored), { name:"RSA-OAEP", hash:"SHA-256" }, false, ["encrypt"]);
  });
}

/* ------------------ Encrypt / Upload ------------------ */
document.getElementById("encryptUploadBtn").onclick = async () => {
  if (!accessToken) return alert("Sign in first");
  document.getElementById("output").textContent = "";

  const password = document.getElementById("password").value;
  const plaintext = document.getElementById("plaintext").value;

  if (!password) { alert("Enter password"); return; }
  if (!localStorage.getItem("identity")) await createIdentity(password);

  const publicKey = await loadPublicKey();
  const fileKey = await crypto.subtle.generateKey({ name:"AES-GCM", length:256 }, true, ["encrypt","decrypt"]);
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ciphertext = await crypto.subtle.encrypt({ name:"AES-GCM", iv }, fileKey, encoder.encode(plaintext));
  const wrappedKey = await crypto.subtle.encrypt({ name:"RSA-OAEP" }, publicKey, await crypto.subtle.exportKey("raw", fileKey));

  const envelope = { iv: bufToBase64(iv), wrappedKey: bufToBase64(wrappedKey), ciphertext: bufToBase64(ciphertext) };
  const form = new FormData();
  form.append("metadata", new Blob([JSON.stringify({ name: "encrypted-envelope.json" })], { type:"application/json" }));
  form.append("file", new Blob([JSON.stringify(envelope)], { type:"application/json" }));

  const res = await fetch("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart", {
    method:"POST",
    headers:{ Authorization:`Bearer ${accessToken}` },
    body: form
  });
  const json = await res.json();
  if (!json.id) throw new Error("Upload failed");
  log("Uploaded File ID: " + json.id);
};

/* ------------------ Download / Decrypt ------------------ */
document.getElementById("downloadDecryptBtn").onclick = async () => {
  if (!accessToken) return alert("Sign in first");
  document.getElementById("output").textContent = "";

  const password = document.getElementById("password").value;
  const fileId = document.getElementById("fileId").value;

  if (!password || !fileId) { alert("Missing password or file ID"); return; }

  const res = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
    headers:{ Authorization:`Bearer ${accessToken}` }
  });
  const envelope = await res.json();

  if (!envelope.iv || !envelope.wrappedKey || !envelope.ciphertext)
    throw new Error("Invalid envelope format");

  const privateKey = await loadPrivateKey(password);
  const rawFileKey = await crypto.subtle.decrypt({ name:"RSA-OAEP" }, privateKey, base64ToBuf(envelope.wrappedKey));
  const fileKey = await crypto.subtle.importKey("raw", rawFileKey, { name:"AES-GCM", length:256 }, false, ["decrypt"]);
  const plaintextBuf = await crypto.subtle.decrypt({ name:"AES-GCM", iv:new Uint8Array(base64ToBuf(envelope.iv)) }, fileKey, base64ToBuf(envelope.ciphertext));

  log("Decrypted text:\n" + decoder.decode(plaintextBuf));
};

/* ------------------ Silent token refresh ------------------ */
setInterval(() => { if (accessToken) tokenClient.requestAccessToken({ prompt:"" }); }, 50*60*1000);
</script>
</body>
</html>
