<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Signal-Style Google Drive Encryption Demo Ver: 5 (Safari-safe)</title>
<style>
body { font-family: sans-serif; max-width: 800px; margin: auto; }
textarea, input { width: 100%; margin: 6px 0; }
button { margin: 6px 0; }
pre { background: #f4f4f4; padding: 10px; overflow-x: auto; }
#userEmail { font-weight: bold; }
</style>
<script src="https://accounts.google.com/gsi/client" async defer onload="initGIS()"></script>
</head>
<body>

<h2>Ver: 5 (Safari-safe)</h2>

<div>
  Signed in as: <span id="userEmail">Not signed in</span>
  <button id="signinBtn">Sign in with Google</button>
  <button id="logoutBtn" disabled>Logout</button>
</div>

<label>Password (used to protect private key)</label>
<input id="password" type="password">

<label>Plaintext to encrypt</label>
<textarea id="plaintext">Hello Google Drive ??</textarea>

<button id="encryptUploadBtn">Encrypt & Upload</button>

<hr>

<label>Google Drive File ID to Download</label>
<input id="fileId">

<button id="downloadDecryptBtn">Download & Decrypt</button>

<h3>Output</h3>
<pre id="output"></pre>

<script>
const encoder = new TextEncoder();
const decoder = new TextDecoder();
let accessToken = null;
let tokenClient = null;

// ---------------- Base64 helpers (Safari-safe) ----------------
function bufToBase64(buf) { return btoa(String.fromCharCode(...new Uint8Array(buf))); }
function base64ToBuf(b64) { return Uint8Array.from(atob(b64), c=>c.charCodeAt(0)).buffer; }

function log(msg) { document.getElementById("output").textContent += msg + "\n"; }

// ---------------- Google Identity ----------------
function initGIS() {
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: "738922366916-ppn1c24mp9qamr6pdmjqss3cqjmvqljv.apps.googleusercontent.com",
    scope: "https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.email",
    callback: async (resp) => {
      accessToken = resp.access_token;
      await fetchUserEmail();
      document.getElementById("signinBtn").disabled = true;
      document.getElementById("logoutBtn").disabled = false;
      log("Signed in successfully.");
    }
  });
}
async function fetchUserEmail() {
  const res = await fetch("https://www.googleapis.com/oauth2/v3/userinfo", { headers: { Authorization: `Bearer ${accessToken}` } });
  const data = await res.json();
  document.getElementById("userEmail").textContent = data.email;
  log("User email: " + data.email);
}
document.getElementById("signinBtn").onclick = () => tokenClient.requestAccessToken({ prompt: "consent" });
document.getElementById("logoutBtn").onclick = () => {
  accessToken = null;
  localStorage.clear();
  document.getElementById("userEmail").textContent = "Not signed in";
  document.getElementById("signinBtn").disabled = false;
  document.getElementById("logoutBtn").disabled = true;
  log("Logged out.");
};

// ---------------- Crypto ----------------
async function deriveKey(password, saltString) {
  const baseKey = await crypto.subtle.importKey("raw", encoder.encode(password), "PBKDF2", false, ["deriveKey"]);
  return crypto.subtle.deriveKey(
    { name:"PBKDF2", salt: encoder.encode(saltString), iterations:250000, hash:"SHA-256" },
    baseKey,
    { name:"AES-GCM", length:256 },
    false,
    ["encrypt","decrypt"]
  );
}

async function createIdentity(password) {
  const keyPair = await crypto.subtle.generateKey({ name:"RSA-OAEP", modulusLength:2048, publicExponent:new Uint8Array([1,0,1]), hash:"SHA-256" }, true, ["encrypt","decrypt"]);
  const pkcs8 = await crypto.subtle.exportKey("pkcs8", keyPair.privateKey);
  const salt = "identity-salt"; // simple string, Safari-safe
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const aesKey = await deriveKey(password, salt);
  const encrypted = await crypto.subtle.encrypt({ name:"AES-GCM", iv }, aesKey, pkcs8);
  localStorage.setItem("identity", JSON.stringify({ salt, iv: bufToBase64(iv), encrypted: bufToBase64(encrypted) }));
  localStorage.setItem("publicKey", bufToBase64(await crypto.subtle.exportKey("spki", keyPair.publicKey)));
  return keyPair;
}

async function loadPrivateKey(password) {
  const stored = JSON.parse(localStorage.getItem("identity"));
  const salt = stored.salt;
  const iv = new Uint8Array(base64ToBuf(stored.iv));
  const encrypted = base64ToBuf(stored.encrypted);
  const aesKey = await deriveKey(password, salt);
  const pkcs8 = await crypto.subtle.decrypt({ name:"AES-GCM", iv }, aesKey, encrypted);
  return crypto.subtle.importKey("pkcs8", pkcs8, { name:"RSA-OAEP", hash:"SHA-256" }, false, ["decrypt"]);
}

async function loadPublicKey() {
  const stored = localStorage.getItem("publicKey");
  return crypto.subtle.importKey("spki", base64ToBuf(stored), { name:"RSA-OAEP", hash:"SHA-256" }, false, ["encrypt"]);
}

// ---------------- Encrypt & Upload (Safari-safe) ----------------
document.getElementById("encryptUploadBtn").onclick = async () => {
  if (!accessToken) return alert("Sign in first");
  document.getElementById("output").textContent = "";

  const password = document.getElementById("password").value;
  const text = document.getElementById("plaintext").value;

  if (!localStorage.getItem("identity")) await createIdentity(password);

  const publicKey = await loadPublicKey();
  const fileKey = await crypto.subtle.generateKey({ name:"AES-GCM", length:256 }, true, ["encrypt","decrypt"]);
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ciphertext = await crypto.subtle.encrypt({ name:"AES-GCM", iv }, fileKey, encoder.encode(text));
  const rawFileKey = await crypto.subtle.exportKey("raw", fileKey);
  const wrappedKey = await crypto.subtle.encrypt({ name:"RSA-OAEP" }, publicKey, rawFileKey);

  // Upload raw binary envelope
  const envelope = new Uint8Array([...iv, ...new Uint8Array(wrappedKey), ...new Uint8Array(ciphertext)]);
  const blob = new Blob([envelope], { type:"application/octet-stream" });

  const form = new FormData();
  form.append("metadata", new Blob([JSON.stringify({ name:"encrypted.bin" })], { type:"application/json" }));
  form.append("file", blob);

  const res = await fetch("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart", {
    method:"POST",
    headers: { Authorization: `Bearer ${accessToken}` },
    body: form
  });
  const json = await res.json();
  log("Uploaded File ID: " + json.id);
};

// ---------------- Download & Decrypt ----------------
document.getElementById("downloadDecryptBtn").onclick = async () => {
  if (!accessToken) return alert("Sign in first");
  document.getElementById("output").textContent = "";

  const password = document.getElementById("password").value;
  const fileId = document.getElementById("fileId").value;
  if (!fileId) return alert("Enter File ID!");

  const res = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
    headers:{ Authorization: `Bearer ${accessToken}` }
  });
  const buf = new Uint8Array(await res.arrayBuffer());

  const privateKey = await loadPrivateKey(password);
  // Simplified: first 12 bytes = iv, next 256 bytes = wrapped AES key, rest = ciphertext
  const iv = buf.slice(0,12);
  const wrappedKey = buf.slice(12, 12+256);
  const ciphertext = buf.slice(12+256);

  const rawFileKey = await crypto.subtle.decrypt({ name:"RSA-OAEP" }, privateKey, wrappedKey);
  const fileKey = await crypto.subtle.importKey("raw", rawFileKey, { name:"AES-GCM", length:256 }, false, ["decrypt"]);
  const plaintextBuf = await crypto.subtle.decrypt({ name:"AES-GCM", iv }, fileKey, ciphertext);

  log("Decrypted text:\n" + decoder.decode(plaintextBuf));
};
</script>
</body>
</html>
