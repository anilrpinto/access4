<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Family Encrypted Drive App</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { font-family: sans-serif; max-width: 800px; margin:auto; }
        textarea,input { width: 100%; margin:6px 0; }
        button { margin:6px 0; }
        pre { background:#f4f4f4; padding:10px; overflow-x:auto; }
        #userEmail { font-weight:bold; }
    </style>
    <script src="https://accounts.google.com/gsi/client" async defer onload="initGIS()"></script>
</head>
<body>

<h2>Family Encrypted Drive Demo</h2>

<div>
    Signed in as: <span id="userEmail">Not signed in</span>
    <button id="signinBtn">Sign in with Google</button>
    <button id="logoutBtn" disabled>Logout</button>
</div>

<label>Password (protect private key)</label>
<input type="password" id="password">

<label>Plaintext to encrypt</label>
<textarea id="plaintext">Hello Family!</textarea>

<label>Recipient emails (comma separated)</label>
<input id="recipients" placeholder="bob@example.com,alice@example.com">

<button id="encryptUploadBtn">Encrypt & Upload</button>

<hr>

<label>Envelope file name to retrieve</label>
<input id="envelopeName" value="family-envelope.json">

<button id="downloadDecryptBtn">Download & Decrypt</button>

<h3>Output</h3>
<pre id="output"></pre>

<script>
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
    let accessToken = null;
    let tokenClient = null;
    let userEmail = null;

    // Logging
    function log(msg){ document.getElementById("output").textContent += msg + "\n"; }
    async function logStep(name, fn){ log(`[${name}] START`); const start=performance.now(); try{ const r=await fn(); log(`[${name}] END (${Math.round(performance.now()-start)}ms)`); return r; } catch(e){ log(`[${name}] FAILED: ${e}`); throw e;}}

    // Base64 helpers
    function bufToBase64(buf){ return btoa(String.fromCharCode(...new Uint8Array(buf))); }
    function base64ToBuf(b64){ const bin=atob(b64); const arr=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) arr[i]=bin.charCodeAt(i); return arr.buffer;}

    // ---------------- Google Identity ----------------
    function initGIS(){
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id:"738922366916-ppn1c24mp9qamr6pdmjqss3cqjmvqljv.apps.googleusercontent.com",
        scope:"https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.email",
        callback: async (resp)=>{ accessToken=resp.access_token; await fetchUserEmail(); log("Signed in."); document.getElementById("signinBtn").disabled=true; document.getElementById("logoutBtn").disabled=false; }
      });
      document.getElementById("signinBtn").onclick = ()=>tokenClient.requestAccessToken({prompt:"consent"});
      document.getElementById("logoutBtn").onclick = logout;
    }

    async function fetchUserEmail(){
      const res = await fetch("https://www.googleapis.com/oauth2/v3/userinfo",{ headers:{Authorization:`Bearer ${accessToken}`}});
      const data=await res.json(); userEmail=data.email; document.getElementById("userEmail").textContent=userEmail;
    }

    // Logout
    function logout(){ accessToken=null; userEmail=null; localStorage.clear(); document.getElementById("userEmail").textContent="Not signed in"; document.getElementById("signinBtn").disabled=false; document.getElementById("logoutBtn").disabled=true; log("Logged out."); }

    // ---------------- Crypto ----------------
    async function deriveKey(password, salt){ const base=await crypto.subtle.importKey("raw", encoder.encode(password),"PBKDF2", false, ["deriveKey"]); return crypto.subtle.deriveKey({ name:"PBKDF2", salt:new Uint8Array(salt), iterations:250000, hash:"SHA-256"}, base,{name:"AES-GCM", length:256}, false, ["encrypt","decrypt"]); }

    async function createIdentity(password){
      const kp = await crypto.subtle.generateKey({name:"RSA-OAEP", modulusLength:2048, publicExponent:new Uint8Array([1,0,1]), hash:"SHA-256"}, true, ["encrypt","decrypt"]);
      const pkcs8 = await crypto.subtle.exportKey("pkcs8", kp.privateKey);
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const aesKey = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt({name:"AES-GCM", iv}, aesKey, pkcs8);
      localStorage.setItem("identity", JSON.stringify({salt:bufToBase64(salt), iv:bufToBase64(iv), encrypted:bufToBase64(encrypted)}));
      localStorage.setItem("publicKey", bufToBase64(await crypto.subtle.exportKey("spki", kp.publicKey)));
      return kp;
    }

    async function loadPrivateKey(password){
      const stored = JSON.parse(localStorage.getItem("identity"));
      if(!stored) throw new Error("No identity found");
      const salt = new Uint8Array(base64ToBuf(stored.salt));
      const iv = new Uint8Array(base64ToBuf(stored.iv));
      const encrypted = base64ToBuf(stored.encrypted);
      const aesKey = await deriveKey(password,salt);
      const pkcs8 = await crypto.subtle.decrypt({name:"AES-GCM", iv}, aesKey, encrypted);
      return crypto.subtle.importKey("pkcs8", pkcs8, {name:"RSA-OAEP", hash:"SHA-256"}, false, ["decrypt"]);
    }

    async function loadPublicKey(){ const stored = localStorage.getItem("publicKey"); if(!stored) throw new Error("No public key found"); return crypto.subtle.importKey("spki", base64ToBuf(stored), {name:"RSA-OAEP", hash:"SHA-256"}, false, ["encrypt"]); }

    // ------------------ Upload Envelope ------------------
    async function encryptAndUpload(){
      if(!accessToken) return alert("Sign in first");
      document.getElementById("output").textContent="";
      const password = document.getElementById("password").value;
      const plaintext = document.getElementById("plaintext").value;
      const recipients = document.getElementById("recipients").value.split(",").map(e=>e.trim()).filter(Boolean);

      if(!localStorage.getItem("identity")) await createIdentity(password);
      const publicKey = await loadPublicKey();

      // AES file key
      const fileKey = await crypto.subtle.generateKey({name:"AES-GCM", length:256}, true, ["encrypt","decrypt"]);
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const ciphertext = await crypto.subtle.encrypt({name:"AES-GCM", iv}, fileKey, encoder.encode(plaintext));
      const rawFileKey = await crypto.subtle.exportKey("raw", fileKey);

      // Envelope
      const envelope = {iv:bufToBase64(iv), ciphertext:bufToBase64(ciphertext), keys:{}};

      // Wrap AES key for creator
      envelope.keys[userEmail] = bufToBase64(await crypto.subtle.encrypt({name:"RSA-OAEP"}, publicKey, rawFileKey));

      // Wrap AES key for recipients
      for(let r of recipients){
        // Fetch their public key from Drive folder /keys/ (simplified: assume stored locally in localStorage for this demo)
        const rKeyStr = localStorage.getItem(`pubkey:${r}`);
        if(!rKeyStr){ log(`No public key for ${r}, skipping.`); continue; }
        const rPubKey = await crypto.subtle.importKey("spki", base64ToBuf(rKeyStr), {name:"RSA-OAEP", hash:"SHA-256"}, false, ["encrypt"]);
        envelope.keys[r] = bufToBase64(await crypto.subtle.encrypt({name:"RSA-OAEP"}, rPubKey, rawFileKey));
      }

      // Upload envelope as JSON to Drive
      const name = "family-envelope.json";
      const form = new FormData();
      form.append("metadata", new Blob([JSON.stringify({name})], {type:"application/json"}));
      form.append("file", new Blob([JSON.stringify(envelope)], {type:"application/json"}));

      const res = await fetch("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart",{
        method:"POST", headers:{Authorization:`Bearer ${accessToken}`}, body:form
      });
      const json = await res.json();
      if(!json.id) throw new Error("Upload failed");
      log(`Envelope uploaded. File ID: ${json.id}`);
    }

    // ------------------ Download & Decrypt ------------------
    async function downloadAndDecrypt(){
      if(!accessToken) return alert("Sign in first");
      document.getElementById("output").textContent="";
      const password = document.getElementById("password").value;
      const envelopeName = document.getElementById("envelopeName").value;

      // List files matching name
      const q = `name='${envelopeName}' and trashed=false`;
      const listRes = await fetch(`https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(q)}&fields=files(id,name)`,{headers:{Authorization:`Bearer ${accessToken}`}});
      const listJson = await listRes.json();
      if(!listJson.files || !listJson.files.length) throw new Error("No envelope found");
      const fileId = listJson.files[0].id;

      // Download file
      const res = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`,{headers:{Authorization:`Bearer ${accessToken}`}});
      const envelope = await res.json();

      if(!envelope.keys[userEmail]) throw new Error("No access for your account");

      const privateKey = await loadPrivateKey(password);
      const wrappedKey = base64ToBuf(envelope.keys[userEmail]);
      const rawFileKey = await crypto.subtle.decrypt({name:"RSA-OAEP"}, privateKey, wrappedKey);
      const fileKey = await crypto.subtle.importKey("raw", rawFileKey, {name:"AES-GCM", length:256}, false, ["decrypt"]);

      const iv = new Uint8Array(base64ToBuf(envelope.iv));
      const ciphertext = base64ToBuf(envelope.ciphertext);
      const plaintextBuf = await crypto.subtle.decrypt({name:"AES-GCM", iv}, fileKey, ciphertext);
      const plaintext = decoder.decode(plaintextBuf);
      log(`Decrypted text:\n${plaintext}`);
    }

    document.getElementById("encryptUploadBtn").onclick = encryptAndUpload;
    document.getElementById("downloadDecryptBtn").onclick = downloadAndDecrypt;

</script>
</body>
</html>
