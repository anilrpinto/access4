<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Access4 â€“ Ver 6 (Step 3.3 + 4, Safari patched for identity storage issues)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <style>
        body { font-family: monospace; max-width: 900px; margin: auto; padding: 12px; }
        button { margin: 6px 0; }
        pre { background: #f4f4f4; padding: 10px; white-space: pre-wrap; }
        #passwordBox { display:none; margin-top:16px; }
        #titleGesture {
            user-select:none;
            -webkit-user-select:none;
            -webkit-touch-callout:none;
        }
    </style>

    <script src="https://accounts.google.com/gsi/client" async defer></script>
</head>

<body>

<h2 id="titleGesture">Access4 â€“ Ver 6 (Step 3.3 + 4, Safari patched for identity storage issues - 1)</h2>

<div>
    Signed in as: <b><span id="userEmail">Not signed in</span></b><br>
    <button id="signinBtn">Sign in with Google</button>
    <button id="logoutBtn" disabled>Logout</button>
</div>

<div id="passwordBox">
    <h3>Device Password</h3>
    <input id="passwordInput" type="password" style="width:100%" />
    <button id="unlockBtn">Unlock</button>
</div>

<h3>Log</h3>
<pre id="log"></pre>

<script>
    /* ================= CONFIG ================= */
    const CLIENT_ID = "738922366916-ppn1c24mp9qamr6pdmjqss3cqjmvqljv.apps.googleusercontent.com";
    const SCOPES = "https://www.googleapis.com/auth/drive https://www.googleapis.com/auth/userinfo.email";
    const ACCESS4_ROOT_ID = "1zQPiXTCDlPjzgD1YZiVKsRB2s4INUS_g";
    const AUTH_FILE_NAME = "authorized.json";
    const PUBKEY_FOLDER_NAME = "pub-keys";

    /* ================= STATE ================= */
    let tokenClient;
    let accessToken = null;
    let userEmail = null;
    let unlockedPassword = null;
    let biometricIntent = false;

    /* ================= LOG ================= */
    function log(msg) {
        document.getElementById("log").textContent += msg + "\n";
    }

    /* ================= GOOGLE SIGN-IN ================= */
    function initGIS() {
        tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: CLIENT_ID,
            scope: SCOPES,
            callback: handleAuth
        });

        document.getElementById("signinBtn").onclick = () =>
            tokenClient.requestAccessToken({ prompt: "consent select_account" });

        document.getElementById("logoutBtn").onclick = logout;

        // Silent attempt
        tokenClient.requestAccessToken({ prompt: "" });
    }

    async function handleAuth(resp) {
        try {
            if (resp.error) return;

            accessToken = resp.access_token;
            log("? Access token acquired");

            await fetchUserEmail();
            await verifySharedRoot();
            await verifyWritable(ACCESS4_ROOT_ID);
            await ensureAuthorization();

            document.getElementById("signinBtn").disabled = true;
            document.getElementById("logoutBtn").disabled = false;
            document.getElementById("passwordBox").style.display = "block";

        } catch (e) {
            log("? " + e.message);
        }
    }

    /* ================= USER ================= */
    async function fetchUserEmail() {
        const res = await fetch("https://www.googleapis.com/oauth2/v3/userinfo", {
            headers: { Authorization: `Bearer ${accessToken}` }
        });
        const data = await res.json();
        userEmail = data.email;
        document.getElementById("userEmail").textContent = userEmail;
        log("Signed in as " + userEmail);
    }

    /* ================= DRIVE HELPERS ================= */
    function buildDriveUrl(path, params = {}) {
        params.supportsAllDrives = true;
        params.includeItemsFromAllDrives = true;
        return `https://www.googleapis.com/drive/v3/${path}?` +
            Object.entries(params).map(([k,v])=>`${k}=${encodeURIComponent(v)}`).join("&");
    }

    async function driveFetch(url, options={}) {
        options.headers ||= {};
        options.headers.Authorization = `Bearer ${accessToken}`;
        const res = await fetch(url, options);
        if (!res.ok) {
            const text = await res.text();
            throw new Error(`Drive error ${res.status}: ${text}`);
        }
        return res.json();
    }

    async function verifyWritable(folderId) {
        log("? Verifying Drive write access (probe)");
        await fetch(buildDriveUrl("files",{q:`'${folderId}' in parents`,pageSize:1}),
            {headers:{Authorization:`Bearer ${accessToken}`}});
        log("? Drive access verified (read OK)");
    }

    /* ================= AUTH ================= */
    async function verifySharedRoot() {
        await driveFetch(buildDriveUrl(`files/${ACCESS4_ROOT_ID}`,{fields:"id"}));
    }

    async function ensureAuthorization() {
        const q = `'${ACCESS4_ROOT_ID}' in parents and name='${AUTH_FILE_NAME}'`;
        const res = await driveFetch(buildDriveUrl("files",{q,fields:"files(id)"}));

        if (!res.files.length) {
            log("? authorized.json not found, creating genesis authorization...");
            await createGenesisAuthorization();
            return;
        }

        const data = await driveFetch(buildDriveUrl(`files/${res.files[0].id}`,{alt:"media"}));
        if (!data.admins.includes(userEmail) && !data.members.includes(userEmail))
            throw new Error("Unauthorized user");

        log("? Authorized user verified");
    }

    async function createGenesisAuthorization() {
        const file = await driveFetch(buildDriveUrl("files"),{
            method:"POST",
            headers:{"Content-Type":"application/json"},
            body:JSON.stringify({name:AUTH_FILE_NAME,parents:[ACCESS4_ROOT_ID]})
        });

        await driveFetch(buildDriveUrl(`files/${file.id}`,{uploadType:"media"}),{
            method:"PATCH",
            headers:{"Content-Type":"application/json"},
            body:JSON.stringify({admins:[userEmail],members:[userEmail],created:new Date().toISOString(),version:1})
        });

        log(`? Genesis authorization created for ${userEmail}`);
    }

    /* ================= IDENTITY ================= */
    function identityKey() { return `access4.identity::${userEmail}`; }
    function loadIdentity() { const raw = localStorage.getItem(identityKey()); return raw ? JSON.parse(raw) : null; }
    function saveIdentity(id) { localStorage.setItem(identityKey(), JSON.stringify(id)); }

    document.getElementById("unlockBtn").onclick = async () => {
        try {
            const pwd = passwordInput.value;
            if (!pwd || pwd.length < 7) throw new Error("Weak password");

            log("?? Unlock attempt started");

            // 1ï¸âƒ£ Check access token
            if (!accessToken) throw new Error("Access token missing");

            // 2ï¸âƒ£ Check local identity
            const id = loadIdentity();

            if (!id) {
                log("?? No local identity found, creating new one");
                await createIdentity(pwd);
            } else {
                log("?? Local identity found");

                // 3ï¸âƒ£ Validate encrypted private key structure
                if (
                    !id.encryptedPrivateKey ||
                    !id.encryptedPrivateKey.iv ||
                    !id.encryptedPrivateKey.data ||
                    !id.kdf
                ) {
                    log("âš ï¸ Malformed identity detected, recreating");
                    await createIdentity(pwd);
                } else {
                    // 4ï¸âƒ£ Attempt decrypt (Safari may fail here even with correct password)
                    let decrypted = false;
                    try {
                        const key = await deriveKey(pwd, id.kdf);
                        await decrypt(id.encryptedPrivateKey, key);
                        decrypted = true;
                        log("âœ… Identity successfully decrypted");
                    } catch (e) {
                        log("âš ï¸ Identity decryption failed on this device (Safari limitation)");
                    }

                    // 5ï¸âƒ£ Safari-safe fallback: recreate identity
                    if (!decrypted) {
                        log("ðŸ” Recreating device identity for Safari compatibility");
                        await createIdentity(pwd);
                    }
                }
            }

            unlockedPassword = pwd;

            // 6ï¸âƒ£ Optional biometric enrollment (unchanged behavior)
            if (biometricIntent) await enrollBiometric(pwd);

            log("?? Proceeding to Step 4: public key exchange");
            await ensureAccountPublicKey();

        } catch (e) {
            log("âŒ Unlock failed: " + e.message);
        }
    };


    async function unlockIdentity(id, pwd) {
        try {
            const key = await deriveKey(pwd, id.kdf);
            await decrypt(id.encryptedPrivateKey, key);
            log("âœ… Identity decrypted successfully");
            return true;
        } catch (e) {
            log("âš ï¸ Decryption failed on this device (Safari limitation)");
            return false;
        }
    }

    async function createIdentity(pwd) {
        log("?? Generating new device identity key pair");

        // Generate RSA 2048 key pair
        const pair = await crypto.subtle.generateKey(
            { name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: "SHA-256" },
            true,
            ["encrypt", "decrypt"]
        );

        // Export keys
        const priv = await crypto.subtle.exportKey("pkcs8", pair.privateKey);
        const pub = await crypto.subtle.exportKey("spki", pair.publicKey);

        // Derive KDF and AES key
        const saltBytes = crypto.getRandomValues(new Uint8Array(16));
        const kdf = { salt: btoa(String.fromCharCode(...saltBytes)), iterations: 100000 };
        const key = await deriveKey(pwd, kdf);

        // Encrypt private key
        const enc = await encrypt(priv, key);

        // Convert public key to Safari-safe base64
        function arrayBufferToBase64Chunked(buf) {
            const chunkSize = 0x8000; // 32k chunks
            let result = "";
            const uint8 = new Uint8Array(buf);
            for (let i = 0; i < uint8.length; i += chunkSize) {
                const subArray = uint8.subarray(i, i + chunkSize);
                result += String.fromCharCode(...subArray);
            }
            return btoa(result);
        }
        const pubB64 = arrayBufferToBase64Chunked(pub);

        // Save identity locally
        saveIdentity({ encryptedPrivateKey: enc, publicKey: pubB64, kdf });
        log("âœ… New identity created and stored locally");

        // Proceed if biometric intent is already armed
        if (biometricIntent) await enrollBiometric(pwd);
    }

    /* ================= CRYPTO ================= */
    async function deriveKey(pwd,kdf) {
        const mat = await crypto.subtle.importKey("raw",new TextEncoder().encode(pwd),"PBKDF2",false,["deriveKey"]);
        return crypto.subtle.deriveKey(
            {name:"PBKDF2",salt:Uint8Array.from(atob(kdf.salt),c=>c.charCodeAt(0)),iterations:kdf.iterations,hash:"SHA-256"},
            mat,{name:"AES-GCM",length:256},false,["encrypt","decrypt"]
        );
    }

    async function decrypt(enc, key) {
        return crypto.subtle.decrypt(
            { name: "AES-GCM", iv: base64ToArrayBufferSafe(enc.iv) },
            key,
            base64ToArrayBufferSafe(enc.data)
        );
    }

    async function encrypt(data, key) {
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const enc = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, data);
        return { iv: arrayBufferToBase64Safe(iv), data: arrayBufferToBase64Safe(enc) };
    }

    function base64ToArrayBufferSafe(b64) {
        try {
            const binary = atob(b64);
            const len = binary.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
            return bytes;
        } catch (e) {
            log("âŒ base64ToArrayBuffer failed: " + e.message);
            throw e;
        }
    }

    function arrayBufferToBase64Safe(buf) {
        try {
            const chunkSize = 0x8000; // 32k chunks
            let result = '';
            const uint8 = new Uint8Array(buf);
            for (let i = 0; i < uint8.length; i += chunkSize) {
                const sub = uint8.subarray(i, i + chunkSize);
                result += String.fromCharCode(...sub);
            }
            return btoa(result);
        } catch (e) {
            log("âŒ arrayBufferToBase64 failed: " + e.message);
            throw e;
        }
    }


    /* ================= BIOMETRIC (HIDDEN) ================= */
    async function enrollBiometric(password) {
        if (!window.PublicKeyCredential) return;
        try {
            await navigator.credentials.get({
                publicKey:{challenge:crypto.getRandomValues(new Uint8Array(32)),userVerification:"required"}
            });
            localStorage.setItem(`access4.bio::${userEmail}`,btoa(password));
            log("?? Hidden biometric shortcut enrolled");
        } catch {
            log("?? Biometric enrollment canceled/failed");
        }
    }

    /* ================= STEP 4: ACCOUNT PUBLIC KEY ================= */
    async function ensureAccountPublicKey() {
        const folder = await findOrCreateFolder();

        const filename = `${userEmail}.json`;
        const q = `'${folder}' in parents and name='${filename}'`;
        const res = await driveFetch(buildDriveUrl("files",{q,fields:"files(id)"}));

        if (res.files.length > 0) {
            log("? Account public key already exists in Drive");
            return res.files[0].id;
        }

        const id = loadIdentity();
        if (!id) throw new Error("Local identity missing");

        const pubData = {
            email: userEmail,
            publicKey: id.publicKey,
            created: new Date().toISOString()
        };

        // Use long boundary and CRLF for Safari compliance
        const boundary = '-------314159265358979323846';
        const body =
            `--${boundary}\r\n` +
            'Content-Type: application/json; charset=UTF-8\r\n\r\n' +
            JSON.stringify({ name: filename, parents: [folder] }) + '\r\n' +
            `--${boundary}\r\n` +
            'Content-Type: application/json\r\n\r\n' +
            JSON.stringify(pubData) + '\r\n' +
            `--${boundary}--`;

        await fetch("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart", {
            method: "POST",
            headers: {
                Authorization: `Bearer ${accessToken}`,
                "Content-Type": `multipart/related; boundary=${boundary}`
            },
            body
        });

        log("? Account public key uploaded");
    }

    async function findOrCreateFolder() {
        const q = `'${ACCESS4_ROOT_ID}' in parents and name='${PUBKEY_FOLDER_NAME}' and mimeType='application/vnd.google-apps.folder'`;
        const res = await driveFetch(buildDriveUrl("files",{q,fields:"files(id)"}));

        if (res.files.length > 0) {
            log(`?? Pub-keys folder found: ${res.files[0].id}`);
            return res.files[0].id;
        }

        log("?? Pub-keys folder not found, creating...");
        const folder = await driveFetch(buildDriveUrl("files"),{
            method:"POST",
            headers:{"Content-Type":"application/json"},
            body:JSON.stringify({name:PUBKEY_FOLDER_NAME,mimeType:"application/vnd.google-apps.folder",parents:[ACCESS4_ROOT_ID]})
        });

        log(`?? Pub-keys folder created: ${folder.id}`);
        return folder.id;
    }

    /* ================= HIDDEN GESTURE ================= */
    (function(){
        const t = document.getElementById("titleGesture");
        let timer=null;
        t.addEventListener("pointerdown",()=>{
            if (!passwordInput.value) return;
            timer=setTimeout(()=>{
                biometricIntent=true;
                log("?? Hidden biometric intent armed");
            },5000);
        });
        ["pointerup","pointerleave","pointercancel"].forEach(e=>t.addEventListener(e,()=>clearTimeout(timer)));
    })();

    /* ================= LOGOUT ================= */
    function logout() {
        accessToken=null;
        userEmail=null;
        location.reload();
    }

    window.onload = initGIS;
</script>
</body>
</html>
