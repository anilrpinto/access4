<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Access4 ‚Äì Ver 6.4 (Reliable Biometric Gesture)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <style>
        body { font-family: monospace; max-width: 900px; margin: auto; padding: 12px; }
        button { margin: 6px 0; }
        pre { background: #f4f4f4; padding: 10px; white-space: pre-wrap; }
        #passwordBox { display:none; margin-top:16px; }
        #titleGesture {
            user-select:none;
            -webkit-user-select:none;
            -webkit-touch-callout:none;
            cursor: pointer;
        }
    </style>

    <script src="https://accounts.google.com/gsi/client" async defer></script>
</head>

<body>

<h2 id="titleGesture">Access4 ‚Äì Ver 6.4</h2>

<div>
    Signed in as: <b><span id="userEmail">Not signed in</span></b><br>
    <button id="signinBtn">Sign in with Google</button>
    <button id="logoutBtn" disabled>Logout</button>
</div>

<div id="passwordBox">
    <h3>Device Password</h3>
    <input id="passwordInput" type="password" style="width:100%" />
    <button id="unlockBtn">Unlock</button>
</div>

<button id="resetBioBtn">Reset Biometric</button>
<script>
    resetBioBtn.onclick = () => {
        localStorage.removeItem(`access4.bio.cred::${userEmail}`);
        localStorage.removeItem(`access4.bio.pwd::${userEmail}`);
        biometricRegistered = false;
        biometricIntent = false;
        log("‚ö†Ô∏è Biometric registration cleared for testing");
    };
</script>

<h3>Log</h3>
<pre id="log"></pre>

<script>
    /* ================= CONFIG ================= */
    const CLIENT_ID = "738922366916-ppn1c24mp9qamr6pdmjqss3cqjmvqljv.apps.googleusercontent.com";
    const SCOPES = "https://www.googleapis.com/auth/drive https://www.googleapis.com/auth/userinfo.email";
    const ACCESS4_ROOT_ID = "1zQPiXTCDlPjzgD1YZiVKsRB2s4INUS_g";
    const AUTH_FILE_NAME = "authorized.json";
    const PUBKEY_FOLDER_NAME = "pub-keys";

    /* ================= STATE ================= */
    let tokenClient;
    let accessToken = null;
    let userEmail = null;
    let unlockedPassword = null;
    let biometricIntent = false; // armed after long press for enrollment
    let biometricRegistered = false;

    /* ================= LOG ================= */
    function log(msg) { document.getElementById("log").textContent += msg + "\n"; }

    /* ================= GOOGLE SIGN-IN ================= */
    function initGIS() {
        tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: CLIENT_ID,
            scope: SCOPES,
            callback: handleAuth
        });

        signinBtn.onclick = () => tokenClient.requestAccessToken({ prompt: "consent select_account" });
        logoutBtn.onclick = logout;

        tokenClient.requestAccessToken({ prompt: "" });
    }

    async function handleAuth(resp) {
        if (resp.error) return;

        accessToken = resp.access_token;
        log("‚úì Access token acquired");

        await fetchUserEmail();
        await verifySharedRoot();
        await verifyWritable(ACCESS4_ROOT_ID);
        await ensureAuthorization();

        signinBtn.disabled = true;
        logoutBtn.disabled = false;
        passwordBox.style.display = "block";

        biometricRegistered = !!localStorage.getItem(bioCredKey());
    }

    /* ================= USER ================= */
    async function fetchUserEmail() {
        const res = await fetch("https://www.googleapis.com/oauth2/v3/userinfo", {
            headers: { Authorization: `Bearer ${accessToken}` }
        });
        const data = await res.json();
        userEmail = data.email;
        document.getElementById("userEmail").textContent = userEmail;
        log("Signed in as " + userEmail);
    }

    /* ================= DRIVE HELPERS ================= */
    function buildDriveUrl(path, params = {}) {
        params.supportsAllDrives = true;
        params.includeItemsFromAllDrives = true;
        return `https://www.googleapis.com/drive/v3/${path}?` +
            Object.entries(params).map(([k,v])=>`${k}=${encodeURIComponent(v)}`).join("&");
    }

    async function driveFetch(url, options={}) {
        options.headers ||= {};
        options.headers.Authorization = `Bearer ${accessToken}`;
        const res = await fetch(url, options);
        if (!res.ok) {
            const text = await res.text();
            throw new Error(`Drive error ${res.status}: ${text}`);
        }
        return res.json();
    }

    async function verifyWritable(folderId) {
        log("? Verifying Drive write access (probe)");
        await fetch(buildDriveUrl("files",{q:`'${folderId}' in parents`,pageSize:1}),
            {headers:{Authorization:`Bearer ${accessToken}`}} );
        log("? Drive access verified (read OK)");
    }

    async function verifySharedRoot() { await driveFetch(buildDriveUrl(`files/${ACCESS4_ROOT_ID}`,{fields:"id"})); }

    async function ensureAuthorization() {
        const q = `'${ACCESS4_ROOT_ID}' in parents and name='${AUTH_FILE_NAME}'`;
        const res = await driveFetch(buildDriveUrl("files",{q,fields:"files(id)"}));
        if (!res.files.length) { log("? authorized.json not found, creating genesis authorization..."); await createGenesisAuthorization(); return; }
        const data = await driveFetch(buildDriveUrl(`files/${res.files[0].id}`,{alt:"media"}));
        if (!data.admins.includes(userEmail) && !data.members.includes(userEmail)) throw new Error("Unauthorized user");
        log("? Authorized user verified");
    }

    async function createGenesisAuthorization() {
        const file = await driveFetch(buildDriveUrl("files"),{
            method:"POST",
            headers:{"Content-Type":"application/json"},
            body:JSON.stringify({name:AUTH_FILE_NAME,parents:[ACCESS4_ROOT_ID]})
        });
        await driveFetch(buildDriveUrl(`files/${file.id}`,{uploadType:"media"}),{
            method:"PATCH",
            headers:{"Content-Type":"application/json"},
            body:JSON.stringify({admins:[userEmail],members:[userEmail],created:new Date().toISOString(),version:1})
        });
        log(`? Genesis authorization created for ${userEmail}`);
    }

    /* ================= IDENTITY ================= */
    function identityKey() { return `access4.identity::${userEmail}`; }
    function loadIdentity() { const raw = localStorage.getItem(identityKey()); return raw ? JSON.parse(raw) : null; }
    function saveIdentity(id) { localStorage.setItem(identityKey(), JSON.stringify(id)); }

    /* ================= CRYPTO ================= */
    async function deriveKey(pwd,kdf) {
        const mat = await crypto.subtle.importKey("raw",new TextEncoder().encode(pwd),"PBKDF2",false,["deriveKey"]);
        return crypto.subtle.deriveKey({name:"PBKDF2",salt:Uint8Array.from(atob(kdf.salt),c=>c.charCodeAt(0)),iterations:kdf.iterations,hash:"SHA-256"},
            mat,{name:"AES-GCM",length:256},false,["encrypt","decrypt"]);
    }
    async function encrypt(data,key){ const iv=crypto.getRandomValues(new Uint8Array(12)); const enc=await crypto.subtle.encrypt({name:"AES-GCM",iv},key,data); return {iv:btoa(String.fromCharCode(...iv)), data:btoa(String.fromCharCode(...new Uint8Array(enc)))};}
    async function decrypt(enc,key){ return crypto.subtle.decrypt({name:"AES-GCM", iv:Uint8Array.from(atob(enc.iv),c=>c.charCodeAt(0))}, key, Uint8Array.from(atob(enc.data),c=>c.charCodeAt(0))); }

    /* ================= CREATE IDENTITY ================= */
    async function createIdentity(pwd) {
        log("?? Generating new device identity key pair");
        const pair = await crypto.subtle.generateKey({ name:"RSA-OAEP", modulusLength:2048, publicExponent:new Uint8Array([1,0,1]), hash:"SHA-256" },true,["encrypt","decrypt"]);
        const priv = await crypto.subtle.exportKey("pkcs8", pair.privateKey);
        const pub = await crypto.subtle.exportKey("spki", pair.publicKey);
        const saltBytes = crypto.getRandomValues(new Uint8Array(16));
        const kdf={salt:btoa(String.fromCharCode(...saltBytes)),iterations:100000};
        const key=await deriveKey(pwd,kdf);
        const enc=await encrypt(priv,key);

        function arrayBufferToBase64Chunked(buf){ const chunkSize=0x8000; let result=""; const uint8=new Uint8Array(buf); for(let i=0;i<uint8.length;i+=chunkSize){ result+=String.fromCharCode(...uint8.subarray(i,i+chunkSize)); } return btoa(result); }

        saveIdentity({encryptedPrivateKey:enc,publicKey:arrayBufferToBase64Chunked(pub),kdf});
        log("‚úÖ New identity created and stored locally");

        if (biometricIntent && !biometricRegistered) { log("?? Biometric enrollment intent detected, enrolling now..."); await enrollBiometric(pwd); biometricRegistered=true; }
    }

    /* ================= UNIFIED UNLOCK FLOW ================= */
    async function unlockIdentityFlow(pwd) {
        if(!pwd||pwd.length<7) throw new Error("Weak password");
        log("?? Unlock attempt started");

        if(!accessToken) throw new Error("Access token missing");

        const id=loadIdentity();
        if(!id){ log("?? No local identity found, creating new one"); await createIdentity(pwd); }
        else{
            log("?? Local identity found");
            if(!id.encryptedPrivateKey||!id.encryptedPrivateKey.iv||!id.encryptedPrivateKey.data||!id.kdf){ log("‚ö†Ô∏è Malformed identity detected, recreating"); await createIdentity(pwd); }
            else{
                let decrypted=false;
                try{ const key=await deriveKey(pwd,id.kdf); await decrypt(id.encryptedPrivateKey,key); decrypted=true; log("‚úÖ Identity successfully decrypted"); }
                catch(e){ log("‚ö†Ô∏è Identity decryption failed on this device (Safari limitation)"); }
                if(!decrypted){ log("üîÅ Recreating device identity for Safari compatibility"); await createIdentity(pwd); }
            }
        }

        unlockedPassword=pwd;
        if(biometricIntent && !biometricRegistered){ await enrollBiometric(pwd); biometricRegistered=true; }

        log("?? Proceeding to Step 4: public key exchange");
        await ensureAccountPublicKey();
    }

    /* ================= DOM CLICK ================= */
    unlockBtn.onclick = async()=>{ try{ await unlockIdentityFlow(passwordInput.value); } catch(e){ log("‚ùå Unlock failed: "+e.message); }};

    /* ================= BIOMETRIC ================= */
    function bioCredKey(){ return `access4.bio.cred::${userEmail}`; }
    function bioPwdKey(){ return `access4.bio.pwd::${userEmail}`; }

    async function enrollBiometric(pwd){
        if(!window.PublicKeyCredential) return;
        const cred = await navigator.credentials.create({ publicKey:{
            challenge:crypto.getRandomValues(new Uint8Array(32)),
            rp:{name:"Access4"},
            user:{id:crypto.getRandomValues(new Uint8Array(16)),name:userEmail,displayName:userEmail},
            pubKeyCredParams:[{type:"public-key",alg:-7}],
            authenticatorSelection:{userVerification:"required"},
            timeout:60000
        }});
        localStorage.setItem(bioCredKey(), btoa(String.fromCharCode(...new Uint8Array(cred.rawId))));
        localStorage.setItem(bioPwdKey(), btoa(pwd));
        log("?? Hidden biometric shortcut enrolled");
    }

    // called directly from single tap gesture
    async function biometricAuthenticateFromGesture() {
        if (!window.PublicKeyCredential) {
            log("‚ö†Ô∏è Biometric not supported on this browser");
            return;
        }

        const rawId = localStorage.getItem(bioCredKey());
        const storedPwd = localStorage.getItem(bioPwdKey());
        if (!rawId || !storedPwd) {
            log("‚ö†Ô∏è No biometric credential stored");
            return;
        }

        try {
            log("?? Triggering biometric prompt...");
            const assertion = await navigator.credentials.get({
                publicKey: {
                    challenge: crypto.getRandomValues(new Uint8Array(32)),
                    allowCredentials: [{
                        type: "public-key",
                        id: Uint8Array.from(atob(rawId), c => c.charCodeAt(0))
                    }],
                    userVerification: "required"
                }
            });
            log("‚úÖ Biometric authentication prompt completed successfully");
            log("?? Using stored password to unlock identity...");
            await unlockIdentityFlow(atob(storedPwd));
        } catch (e) {
            log("‚ö†Ô∏è Biometric prompt failed or canceled: " + e.message);
        }
    }

    /* ================= STEP 4: ACCOUNT PUBLIC KEY ================= */
    async function ensureAccountPublicKey(){ const folder=await findOrCreateFolder(); const filename=`${userEmail}.json`; const q=`'${folder}' in parents and name='${filename}'`; const res=await driveFetch(buildDriveUrl("files",{q,fields:"files(id)"})); if(res.files.length>0){log("? Account public key already exists in Drive"); return;} const id=loadIdentity(); if(!id) throw new Error("Local identity missing"); const pubData={email:userEmail,publicKey:id.publicKey,created:new Date().toISOString()}; const boundary="-------314159265358979323846"; const body=`--${boundary}\r\nContent-Type: application/json\r\n\r\n`+JSON.stringify({name:filename,parents:[folder]})+"\r\n"+`--${boundary}\r\nContent-Type: application/json\r\n\r\n`+JSON.stringify(pubData)+`\r\n--${boundary}--`; await fetch("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart",{method:"POST", headers:{Authorization:`Bearer ${accessToken}`,"Content-Type":`multipart/related; boundary=${boundary}`},body}); log("? Account public key uploaded"); }

    async function findOrCreateFolder(){ const q=`'${ACCESS4_ROOT_ID}' in parents and name='${PUBKEY_FOLDER_NAME}' and mimeType='application/vnd.google-apps.folder'`; const res=await driveFetch(buildDriveUrl("files",{q,fields:"files(id)"})); if(res.files.length>0) return res.files[0].id; log("?? Pub-keys folder not found, creating..."); const folder=await driveFetch(buildDriveUrl("files"),{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({name:PUBKEY_FOLDER_NAME,mimeType:"application/vnd.google-apps.folder",parents:[ACCESS4_ROOT_ID]})}); log(`?? Pub-keys folder created: ${folder.id}`); return folder.id; }

    /* ================= HIDDEN GESTURE ================= */

    function armBiometric() {
        biometricIntent = true;
        log("?? Hidden biometric intent armed");

        // If password already unlocked and biometric not yet registered, enroll immediately
        if (unlockedPassword && !biometricRegistered) {
            log("?? Password already unlocked, enrolling biometric immediately...");
            enrollBiometric(unlockedPassword).then(() => {
                biometricRegistered = true;
            });
        }
    }

    // Long press handler
    (()=>{
        const t = document.getElementById("titleGesture");
        let timer = null;

        t.addEventListener("pointerdown", () => {
            timer = setTimeout(armBiometric, 5000);
        });
        ["pointerup","pointerleave","pointercancel"].forEach(e => t.addEventListener(e, () => clearTimeout(timer)));

        // Single tap triggers biometric if already registered
        t.addEventListener("click", async () => {
            if (!biometricRegistered) return;
            await biometricAuthenticateFromGesture();
        });
    })();


    /* ================= LOGOUT ================= */
    function logout(){ accessToken=null; userEmail=null; location.reload(); }

    window.onload=initGIS;
</script>
</body>
</html>
