<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Access4 ‚Äì Ver 6.5 (Step 5.1 Envelope creation, encryption and decryption local only)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <style>
        body { font-family: monospace; max-width: 900px; margin: auto; padding: 12px; }
        button { margin: 6px 0; }
        pre { background: #f4f4f4; padding: 10px; white-space: pre-wrap; }
        #passwordBox { display:none; margin-top:16px; }
        #titleGesture {
            user-select:none;
            -webkit-user-select:none;
            -webkit-touch-callout:none;
            cursor: pointer;
        }
    </style>

    <script src="https://accounts.google.com/gsi/client" async defer></script>
</head>

<body>

<h2 id="titleGesture">Access4 ‚Äì Ver 6.5 (Step 4.1)</h2>

<div>
    Signed in as: <b><span id="userEmail">Not signed in</span></b><br>
    <button id="signinBtn">Sign in with Google</button>
    <button id="logoutBtn" disabled>Logout</button>
</div>

<div id="passwordBox">
    <h3>Device Password</h3>
    <input id="passwordInput" type="password" style="width:100%" />
    <button id="unlockBtn">Unlock</button>
</div>

<button id="resetBioBtn">Reset Biometric</button>

<br/><button onclick="testStep5_1()">Test Step 5.1</button><br/>
<h3>Log</h3>
<pre id="log"></pre>

<script>
    /* ================= CONFIG ================= */
    const CLIENT_ID = "738922366916-ppn1c24mp9qamr6pdmjqss3cqjmvqljv.apps.googleusercontent.com";
    const SCOPES = "https://www.googleapis.com/auth/drive https://www.googleapis.com/auth/userinfo.email";
    const ACCESS4_ROOT_ID = "1zQPiXTCDlPjzgD1YZiVKsRB2s4INUS_g";
    const AUTH_FILE_NAME = "authorized.json";
    const PUBKEY_FOLDER_NAME = "pub-keys";

    /* ================= STATE ================= */
    let tokenClient;
    let accessToken = null;
    let userEmail = null;
    let unlockedPassword = null;
    let biometricIntent = false;
    let biometricRegistered = false;

    /* ================= LOG ================= */
    function log(msg) {
        document.getElementById("log").textContent += msg + "\n";
    }

    /* ================= DEVICE ID (4.1) ================= */
    function deviceIdKey() { return "access4.device.id"; }

    function getDeviceId() {
        let id = localStorage.getItem(deviceIdKey());
        if (!id) {
            id = crypto.randomUUID();
            localStorage.setItem(deviceIdKey(), id);
            log("üÜî New device ID generated");
        }
        return id;
    }

    /* ================= GOOGLE SIGN-IN ================= */
    function initGIS() {
        tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: CLIENT_ID,
            scope: SCOPES,
            callback: handleAuth
        });

        signinBtn.onclick = () => tokenClient.requestAccessToken({ prompt: "consent select_account" });
        logoutBtn.onclick = logout;
        tokenClient.requestAccessToken({ prompt: "" });
    }

    async function handleAuth(resp) {
        if (resp.error) return;

        accessToken = resp.access_token;
        log("‚úì Access token acquired");

        await fetchUserEmail();
        await verifySharedRoot();
        await verifyWritable(ACCESS4_ROOT_ID);
        await ensureAuthorization();

        signinBtn.disabled = true;
        logoutBtn.disabled = false;
        passwordBox.style.display = "block";

        biometricRegistered = !!localStorage.getItem(bioCredKey());
    }

    /* ================= USER ================= */
    async function fetchUserEmail() {
        const res = await fetch("https://www.googleapis.com/oauth2/v3/userinfo", {
            headers: { Authorization: `Bearer ${accessToken}` }
        });
        const data = await res.json();
        userEmail = data.email;
        document.getElementById("userEmail").textContent = userEmail;
        log("Signed in as xxx@gmail.com"); //+ userEmail);
    }

    /* ================= DRIVE HELPERS ================= */
    function buildDriveUrl(path, params = {}) {
        params.supportsAllDrives = true;
        params.includeItemsFromAllDrives = true;
        return `https://www.googleapis.com/drive/v3/${path}?` +
            Object.entries(params).map(([k,v])=>`${k}=${encodeURIComponent(v)}`).join("&");
    }

    async function driveFetch(url, options={}) {
        options.headers ||= {};
        options.headers.Authorization = `Bearer ${accessToken}`;
        const res = await fetch(url, options);
        if (!res.ok) throw new Error(await res.text());
        return res.json();
    }

    async function driveMultipartUpload({metadata, content, contentType = "application/json" }) {
        const boundary = "-------access4-" + crypto.randomUUID();

        const body =
            `--${boundary}\r\n` +
            `Content-Type: application/json; charset=UTF-8\r\n\r\n` +
            JSON.stringify(metadata) + "\r\n" +
            `--${boundary}\r\n` +
            `Content-Type: ${contentType}\r\n\r\n` +
            content + "\r\n" +
            `--${boundary}--`;

        const res = await fetch(
            "https://www.googleapis.com/upload/drive/v3/files" +
            "?uploadType=multipart&supportsAllDrives=true",
            {
                method: "POST",
                headers: {
                    Authorization: `Bearer ${accessToken}`,
                    "Content-Type": `multipart/related; boundary=${boundary}`
                },
                body
            }
        );

        if (!res.ok) {
            const text = await res.text();
            throw new Error(`Multipart upload failed ${res.status}: ${text}`);
        }

        return res;
    }

    async function verifyWritable(folderId) {
        log("? Verifying Drive write access (probe)");
        await fetch(buildDriveUrl("files",{q:`'${folderId}' in parents`,pageSize:1}),
            {headers:{Authorization:`Bearer ${accessToken}`}} );
        log("? Drive access verified (read OK)");
    }

    async function verifySharedRoot() {
        await driveFetch(buildDriveUrl(`files/${ACCESS4_ROOT_ID}`,{fields:"id"}));
    }

    /* ================= AUTH ================= */
    async function ensureAuthorization() {
        const q = `'${ACCESS4_ROOT_ID}' in parents and name='${AUTH_FILE_NAME}'`;
        const res = await driveFetch(buildDriveUrl("files",{q,fields:"files(id)"}));
        if (!res.files.length) {
            log("? authorized.json not found, creating genesis authorization...");
            await createGenesisAuthorization();
            return;
        }
        const data = await driveFetch(buildDriveUrl(`files/${res.files[0].id}`,{alt:"media"}));
        if (!data.admins.includes(userEmail) && !data.members.includes(userEmail))
            throw new Error("Unauthorized user");
        log("? Authorized user verified");
    }

    async function createGenesisAuthorization() {
        const file = await driveFetch(buildDriveUrl("files"),{
            method:"POST",
            headers:{"Content-Type":"application/json"},
            body:JSON.stringify({name:AUTH_FILE_NAME,parents:[ACCESS4_ROOT_ID]})
        });
        await driveFetch(buildDriveUrl(`files/${file.id}`,{uploadType:"media"}),{
            method:"PATCH",
            headers:{"Content-Type":"application/json"},
            body:JSON.stringify({
                admins:[userEmail],
                members:[userEmail],
                created:new Date().toISOString(),
                version:1
            })
        });
        log(`? Genesis authorization created for ${userEmail}`);
    }

    /* ================= IDENTITY (4.1) ================= */
    function identityKey() {
        return `access4.identity::${userEmail}::${getDeviceId()}`;
    }

    function loadIdentity() {
        const raw = localStorage.getItem(identityKey());
        return raw ? JSON.parse(raw) : null;
    }

    function saveIdentity(id) {
        localStorage.setItem(identityKey(), JSON.stringify(id));
    }

    /* ================= CRYPTO ================= */
    async function deriveKey(pwd,kdf) {
        const mat = await crypto.subtle.importKey(
            "raw",
            new TextEncoder().encode(pwd),
            "PBKDF2",
            false,
            ["deriveKey"]
        );
        return crypto.subtle.deriveKey(
            {
                name:"PBKDF2",
                salt:Uint8Array.from(atob(kdf.salt),c=>c.charCodeAt(0)),
                iterations:kdf.iterations,
                hash:"SHA-256"
            },
            mat,
            {name:"AES-GCM",length:256},
            false,
            ["encrypt","decrypt"]
        );
    }

    async function encrypt(data,key){
        const iv=crypto.getRandomValues(new Uint8Array(12));
        const enc=await crypto.subtle.encrypt({name:"AES-GCM",iv},key,data);
        return {
            iv:btoa(String.fromCharCode(...iv)),
            data:btoa(String.fromCharCode(...new Uint8Array(enc)))
        };
    }

    async function decrypt(enc,key){
        return crypto.subtle.decrypt(
            {name:"AES-GCM", iv:Uint8Array.from(atob(enc.iv),c=>c.charCodeAt(0))},
            key,
            Uint8Array.from(atob(enc.data),c=>c.charCodeAt(0))
        );
    }

    /* ================= CREATE IDENTITY ================= */
    async function createIdentity(pwd) {
        log("üîê Generating new device identity key pair");
        const pair = await crypto.subtle.generateKey(
            { name:"RSA-OAEP", modulusLength:2048, publicExponent:new Uint8Array([1,0,1]), hash:"SHA-256" },
            true,
            ["encrypt","decrypt"]
        );

        const priv = await crypto.subtle.exportKey("pkcs8", pair.privateKey);
        const pub = await crypto.subtle.exportKey("spki", pair.publicKey);
        const saltBytes = crypto.getRandomValues(new Uint8Array(16));

        const kdf={salt:btoa(String.fromCharCode(...saltBytes)),iterations:100000};
        const key=await deriveKey(pwd,kdf);
        const enc=await encrypt(priv,key);

        function ab2b64(buf){
            return btoa(String.fromCharCode(...new Uint8Array(buf)));
        }

        saveIdentity({
            encryptedPrivateKey:enc,
            publicKey:ab2b64(pub),
            kdf,
            deviceId:getDeviceId(),
            email:userEmail,
            created:new Date().toISOString()
        });

        log("‚úÖ New identity created and stored locally");

        if (biometricIntent && !biometricRegistered) {
            log("üëÜ Biometric enrollment intent detected, enrolling now...");
            await enrollBiometric(pwd);
            biometricRegistered = true;
        }
    }

    /* ================= UNLOCK FLOW ================= */
    async function unlockIdentityFlow(pwd) {
        if(!pwd||pwd.length<7) throw new Error("Weak password");
        log("üîì Unlock attempt started");

        if(!accessToken) throw new Error("Access token missing");

        const id=loadIdentity();
        if(!id){
            log("üìÅ No local identity found, creating new one");
            await createIdentity(pwd);
        } else {
            log("üìÅ Local identity found");
            let decrypted=false;
            try {
                const key=await deriveKey(pwd,id.kdf);
                await decrypt(id.encryptedPrivateKey,key);
                decrypted=true;
                log("‚úÖ Identity successfully decrypted");
            } catch {
                log("‚ö†Ô∏è Identity decryption failed on this device (Safari limitation)");
            }
            if(!decrypted){
                log("üîÅ Recreating device identity for Safari compatibility");
                await createIdentity(pwd);
            }
        }

        unlockedPassword=pwd;
        if(biometricIntent && !biometricRegistered){
            await enrollBiometric(pwd);
            biometricRegistered=true;
        }

        log("üîë Proceeding to Step 4.1: device public key exchange");
        await ensureDevicePublicKey();
    }

    unlockBtn.onclick = async()=> {
        try { await unlockIdentityFlow(passwordInput.value); }
        catch(e){ log("‚ùå Unlock failed: "+e.message); }
    };

    /* ================= BIOMETRIC ================= */
    function bioCredKey(){
        return `access4.bio.cred::${userEmail}::${getDeviceId()}`;
    }
    function bioPwdKey(){
        return `access4.bio.pwd::${userEmail}::${getDeviceId()}`;
    }

    resetBioBtn.onclick = () => {
        localStorage.removeItem(bioCredKey());
        localStorage.removeItem(bioPwdKey());
        biometricRegistered = false;
        biometricIntent = false;
        log("‚ö†Ô∏è Biometric registration cleared for testing");
    };

    async function enrollBiometric(pwd){
        if(!window.PublicKeyCredential) return;
        const cred = await navigator.credentials.create({
            publicKey:{
                challenge:crypto.getRandomValues(new Uint8Array(32)),
                rp:{name:"Access4"},
                user:{id:crypto.getRandomValues(new Uint8Array(16)),name:userEmail,displayName:userEmail},
                pubKeyCredParams:[{type:"public-key",alg:-7}],
                authenticatorSelection:{userVerification:"required"},
                timeout:60000
            }
        });
        localStorage.setItem(bioCredKey(), btoa(String.fromCharCode(...new Uint8Array(cred.rawId))));
        localStorage.setItem(bioPwdKey(), btoa(pwd));
        log("üß¨ Hidden biometric shortcut enrolled");
    }

    async function biometricAuthenticateFromGesture() {
        if (!window.PublicKeyCredential) {
            log("‚ö†Ô∏è Biometric not supported on this browser");
            return;
        }

        const rawId = localStorage.getItem(bioCredKey());
        const storedPwd = localStorage.getItem(bioPwdKey());
        if (!rawId || !storedPwd) {
            log("‚ö†Ô∏è No biometric credential stored");
            return;
        }

        try {
            log("üëÜ Triggering biometric prompt...");
            await navigator.credentials.get({
                publicKey:{
                    challenge:crypto.getRandomValues(new Uint8Array(32)),
                    allowCredentials:[{
                        type:"public-key",
                        id:Uint8Array.from(atob(rawId),c=>c.charCodeAt(0))
                    }],
                    userVerification:"required"
                }
            });
            log("‚úÖ Biometric authentication prompt completed successfully");
            log("üîì Using stored password to unlock identity...");
            await unlockIdentityFlow(atob(storedPwd));
        } catch(e){
            log("‚ö†Ô∏è Biometric prompt failed or canceled: "+e.message);
        }
    }

    /* ================= STEP 4.1: DEVICE PUBLIC KEY ================= */
    async function ensureDevicePublicKey() {
        const folder = await findOrCreateUserFolder();

        const deviceId = getDeviceId();
        const filename = `${userEmail}__${deviceId}.json`;

        const q = `'${folder}' in parents and name='${filename}'`;
        const res = await driveFetch(buildDriveUrl("files", { q, fields: "files(id)" }));

        if (res.files.length > 0) {
            log("?? Device public key already exists in Drive");
            return;
        }

        const id = loadIdentity();
        if (!id) throw new Error("Local identity missing");

        // Compute fingerprint
        const pubBytes = Uint8Array.from(atob(id.publicKey), c => c.charCodeAt(0));
        const hashBuffer = await crypto.subtle.digest("SHA-256", pubBytes);
        const fingerprint = btoa(String.fromCharCode(...new Uint8Array(hashBuffer)));

        // Device metadata
        const deviceName = `${navigator.platform} - ${navigator.userAgent}`.substring(0, 64);
        const browser = navigator.userAgentData?.brands?.map(b => b.brand).join(",") || navigator.userAgent;
        const os = navigator.platform;

        const pubData = {
            version: "4.1",
            account: userEmail,
            deviceId,
            created: new Date().toISOString(),
            algorithm: {
                type: "RSA",
                usage: ["wrapKey"],
                modulusLength: 2048,
                hash: "SHA-256"
            },
            publicKey: {
                format: "spki",
                encoding: "base64",
                data: id.publicKey
            },
            fingerprint,
            deviceName,
            browser,
            os
        };

        await driveMultipartUpload({
            metadata: { name: filename, parents: [folder] },
            content: JSON.stringify(pubData)
        });

        log("?? Device public key uploaded (4.1 with full metadata)");
    }

    async function findOrCreateUserFolder(){
        const rootQ = `'${ACCESS4_ROOT_ID}' in parents and name='${PUBKEY_FOLDER_NAME}' and mimeType='application/vnd.google-apps.folder'`;
        const rootRes = await driveFetch(buildDriveUrl("files",{q:rootQ,fields:"files(id)"}));
        const root = rootRes.files.length ? rootRes.files[0].id :
            (await driveFetch(buildDriveUrl("files"),{
                method:"POST",
                headers:{"Content-Type":"application/json"},
                body:JSON.stringify({
                    name:PUBKEY_FOLDER_NAME,
                    mimeType:"application/vnd.google-apps.folder",
                    parents:[ACCESS4_ROOT_ID]
                })
            })).id;

        const userQ = `'${root}' in parents and name='${userEmail}' and mimeType='application/vnd.google-apps.folder'`;
        const userRes = await driveFetch(buildDriveUrl("files",{q:userQ,fields:"files(id)"}));
        if(userRes.files.length) return userRes.files[0].id;

        const folder = await driveFetch(buildDriveUrl("files"),{
            method:"POST",
            headers:{"Content-Type":"application/json"},
            body:JSON.stringify({
                name:userEmail,
                mimeType:"application/vnd.google-apps.folder",
                parents:[root]
            })
        });

        return folder.id;
    }

    /* ================= STEP 5: DEVICE PUBLIC KEY ================= */

    async function generateContentKey() {
        return crypto.subtle.generateKey(
            { name: "AES-GCM", length: 256 },
            true,
            ["encrypt", "decrypt"]
        );
    }

    /* --- Encrypt Payload with CEK --- */
    async function encryptPayload(plainText, cek) {
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const encoded = new TextEncoder().encode(plainText);

        const ciphertext = await crypto.subtle.encrypt(
            { name: "AES-GCM", iv },
            cek,
            encoded
        );

        return {
            iv: btoa(String.fromCharCode(...iv)),
            data: btoa(String.fromCharCode(...new Uint8Array(ciphertext)))
        };
    }

    /* --- Wrap CEK for a Device Public Key --- */
    async function wrapContentKeyForDevice(cek, devicePublicKeyBase64) {
        const pubKeyBytes = Uint8Array.from(atob(devicePublicKeyBase64), c => c.charCodeAt(0));

        const publicKey = await crypto.subtle.importKey(
            "spki",
            pubKeyBytes,
            { name: "RSA-OAEP", hash: "SHA-256" },
            false,
            ["wrapKey"]
        );

        const wrapped = await crypto.subtle.wrapKey(
            "raw",
            cek,
            publicKey,
            { name: "RSA-OAEP" }
        );

        return btoa(String.fromCharCode(...new Uint8Array(wrapped)));
    }

    /* ---Unwrap CEK Using Local Private Key --- */
    async function unwrapContentKey(wrappedKeyBase64) {
        const id = loadIdentity();
        if (!id) throw new Error("Local identity missing");

        const pwd = unlockedPassword;
        if (!pwd) throw new Error("Identity not unlocked");

        const key = await deriveKey(pwd, id.kdf);
        const privBuf = await decrypt(id.encryptedPrivateKey, key);

        const privateKey = await crypto.subtle.importKey(
            "pkcs8",
            privBuf,
            { name: "RSA-OAEP", hash: "SHA-256" },
            false,
            ["unwrapKey"]
        );

        const wrappedBytes = Uint8Array.from(atob(wrappedKeyBase64), c => c.charCodeAt(0));

        return crypto.subtle.unwrapKey(
            "raw",
            wrappedBytes,
            privateKey,
            { name: "RSA-OAEP" },
            { name: "AES-GCM", length: 256 },
            false,
            ["decrypt"]
        );
    }

    async function createEnvelope(plainText, devicePublicKeyRecord) {
        const cek = await generateContentKey();
        const payload = await encryptPayload(plainText, cek);

        const wrappedKey = await wrapContentKeyForDevice(
            cek,
            devicePublicKeyRecord.publicKey.data
        );

        return {
            version: "1.0",
            cipher: {
                payload: "AES-256-GCM",
                keyWrap: "RSA-OAEP-SHA256"
            },
            payload,
            keys: [{
                account: devicePublicKeyRecord.account,
                deviceId: devicePublicKeyRecord.deviceId,
                keyId: devicePublicKeyRecord.fingerprint,
                keyVersion: devicePublicKeyRecord.version,
                wrappedKey
            }],
            created: new Date().toISOString()
        };
    }

    async function openEnvelope(envelope) {
        const entry = envelope.keys.find(k => k.deviceId === getDeviceId());
        if (!entry) throw new Error("No key entry for this device");

        const cek = await unwrapContentKey(entry.wrappedKey);

        const iv = Uint8Array.from(atob(envelope.payload.iv), c => c.charCodeAt(0));
        const data = Uint8Array.from(atob(envelope.payload.data), c => c.charCodeAt(0));

        const decrypted = await crypto.subtle.decrypt(
            { name: "AES-GCM", iv },
            cek,
            data
        );

        return new TextDecoder().decode(decrypted);
    }

    async function testStep5_1() {
        log("üß™ Step 5.1 test started");

        // 1Ô∏è‚É£ Ensure identity is unlocked
        const id = loadIdentity();
        if (!id) throw new Error("No local identity");

        if (!unlockedPassword) {
            throw new Error("Identity must be unlocked first");
        }

        // 2Ô∏è‚É£ Construct a mock device public-key record
        const deviceRecord = {
            account: userEmail,
            deviceId: getDeviceId(),
            version: "1.0",
            fingerprint: id.fingerprint,
            publicKey: {
                data: id.publicKey
            }
        };

        if (!deviceRecord.fingerprint) {
            log("WARN: Envelope created without keyId (Step 5.1 test mode)");
        }

        // 3Ô∏è‚É£ Encrypt test payload
        const message = "Hello Step 5.1 ‚Äì envelope crypto works ‚úÖ";

        const envelope = await createEnvelope(message, deviceRecord);
        log("üì¶ Envelope created: " + JSON.stringify(envelope));

        // 4Ô∏è‚É£ Decrypt it
        const decrypted = await openEnvelope(envelope);

        log("üîì Decrypted payload: " + decrypted);

        // 5Ô∏è‚É£ Assert
        if (decrypted !== message) {
            throw new Error("‚ùå Step 5.1 FAILED: plaintext mismatch");
        }

        log("‚úÖ Step 5.1 PASSED");
    }

    /* ================= HIDDEN GESTURE ================= */
    function armBiometric() {
        biometricIntent = true;
        log("üëÜ Hidden biometric intent armed");

        if (unlockedPassword && !biometricRegistered) {
            log("üîê Password already unlocked, enrolling biometric immediately...");
            enrollBiometric(unlockedPassword).then(()=>biometricRegistered=true);
        }
    }

    (()=>{
        const t=document.getElementById("titleGesture");
        let timer=null;
        t.addEventListener("pointerdown",()=>timer=setTimeout(armBiometric,5000));
        ["pointerup","pointerleave","pointercancel"].forEach(e=>t.addEventListener(e,()=>clearTimeout(timer)));
        t.addEventListener("click",async()=>{
            if(!biometricRegistered) return;
            await biometricAuthenticateFromGesture();
        });
    })();

    /* ================= LOGOUT ================= */
    function logout(){
        accessToken=null;
        userEmail=null;
        location.reload();
    }

    window.onload=initGIS;
</script>
</body>
</html>
