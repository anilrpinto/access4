<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Access4 – Ver 6 Step 4</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <style>
        body { font-family: monospace; max-width: 900px; margin: auto; padding: 12px; }
        button { margin: 6px 0; }
        pre { background: #f4f4f4; padding: 10px; white-space: pre-wrap; }
    </style>

    <script src="https://accounts.google.com/gsi/client" async defer></script>
</head>

<body>
<h2>Access4 – Ver 6 (Step 4: Public key to drive)</h2>

<div>
    Signed in as: <b><span id="userEmail">Not signed in</span></b><br>
    <button id="signinBtn">Sign in with Google</button>
    <button id="logoutBtn" disabled>Logout</button>
</div>

<h3>Log</h3>
<pre id="log"></pre>

<script>
    /* ================== CONFIG ================== */

    const CLIENT_ID = "738922366916-ppn1c24mp9qamr6pdmjqss3cqjmvqljv.apps.googleusercontent.com";
    const SCOPES = "https://www.googleapis.com/auth/drive https://www.googleapis.com/auth/userinfo.email";

    // Shared Drive / folder root (hardcoded)
    const ACCESS4_ROOT_ID = "1zQPiXTCDlPjzgD1YZiVKsRB2s4INUS_g";
    const AUTH_FILE_NAME = "authorized.json";

    /* ================== STATE ================== */

    let tokenClient;
    let accessToken = null;
    let userEmail = null;

    /* ================== LOGGING ================== */

    function log(msg) {
        document.getElementById("log").textContent += msg + "\n";
    }

    /* ================== INIT GIS ================== */

    function initGIS() {
        tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: CLIENT_ID,
            scope: SCOPES,
            callback: async (resp) => {
                try {
                    if (resp.error) throw resp.error;

                    accessToken = resp.access_token;
                    log("Access token acquired");

                    await fetchUserEmail();
                    await verifySharedRoot();
                    await verifyWritable(ACCESS4_ROOT_ID);   // ✅ probe access
                    await ensureAuthorization();
                    await ensureIdentity();
                    await ensureAccountPublicKey(); // Step 4

                    document.getElementById("signinBtn").disabled = true;
                    document.getElementById("logoutBtn").disabled = false;

                } catch (e) {
                    log("❌ " + e.message);
                }
            }
        });

        document.getElementById("signinBtn").onclick = () =>
            tokenClient.requestAccessToken({
                prompt: "consent select_account"
            });

        document.getElementById("logoutBtn").onclick = logout;
    }

    /* ================== USER INFO ================== */

    async function fetchUserEmail() {
        const res = await fetch("https://www.googleapis.com/oauth2/v3/userinfo", {
            headers: { Authorization: `Bearer ${accessToken}` }
        });
        const data = await res.json();
        userEmail = data.email;
        document.getElementById("userEmail").textContent = userEmail;
        log("Signed in as: " + userEmail);
    }

    /* ================== DRIVE HELPERS ================== */

    function buildDriveUrl(path, params = {}) {
        // Standardize query params including support for shared drives
        params.supportsAllDrives = true;
        params.includeItemsFromAllDrives = true;

        const query = Object.keys(params)
            .map(k => `${encodeURIComponent(k)}=${encodeURIComponent(params[k])}`)
            .join("&");

        return `https://www.googleapis.com/drive/v3/${path}?${query}`;
    }

    async function driveFetch(url, options = {}) {
        options.headers = options.headers || {};
        options.headers.Authorization = `Bearer ${accessToken}`;

        const res = await fetch(url, options);
        if (!res.ok) {
            const text = await res.text();
            throw new Error(`Drive error ${res.status}: ${text}`);
        }
        return res.json();
    }

    // Quick probe to see if user has write access
    async function verifyWritable(folderId) {
        log("Verifying Drive write access (probe)");

        try {
            const url = buildDriveUrl("files", {
                q: `'${folderId}' in parents`,
                pageSize: 1
            });

            const res = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` } });
            if (!res.ok) throw new Error("Unable to list folder contents");

            log("Drive access verified (read OK)");
        } catch (e) {
            throw new Error("You do not have sufficient access to the Access4 shared folder.");
        }
    }

    /* ================== STEP 1: VERIFY ROOT ================== */

    async function verifySharedRoot() {
        log("Verifying shared Access4 root folder");

        try {
            const url = buildDriveUrl(`files/${ACCESS4_ROOT_ID}`, { fields: "id,name" });
            const meta = await driveFetch(url);

            log(`Using shared root folder: "${meta.name}" (${meta.id})`);
            return meta.id;

        } catch (e) {
            if (e.message.includes("404")) {
                throw new Error(
                    "Access4 shared folder not accessible. " +
                    "You must be granted access to the shared folder before using this app."
                );
            }
            throw e;
        }
    }

    /* ================== STEP 2: AUTHORIZATION ================== */

    async function ensureAuthorization() {
        log("Checking authorization state");

        const query = `'${ACCESS4_ROOT_ID}' in parents and name='${AUTH_FILE_NAME}' and trashed=false`;

        const url = buildDriveUrl("files", {
            q: query,
            fields: "files(id,name)"
        });

        const list = await driveFetch(url);

        if (list.files.length === 0) {
            log("authorized.json not found");
            await createGenesisAuthorization();
            return;
        }

        const authFileId = list.files[0].id;
        log("authorized.json found");

        const authData = await driveFetch(buildDriveUrl(`files/${authFileId}`, { alt: "media" }));

        const isAuthorized =
            authData.admins.includes(userEmail) ||
            authData.members.includes(userEmail);

        if (!isAuthorized) {
            log("❌ Access denied: user not authorized");
            throw new Error("Unauthorized user");
        }

        log("✅ Authorized user verified");
    }

    /* ================== GENESIS ================== */

    async function createGenesisAuthorization() {
        log("Creating genesis authorization");

        const data = {
            admins: [userEmail],
            members: [userEmail],
            created: new Date().toISOString(),
            version: 1
        };

        // authorized.json creation
        const file = await driveFetch(buildDriveUrl("files"), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                name: AUTH_FILE_NAME,
                mimeType: "application/json",
                parents: [ACCESS4_ROOT_ID]
            })
        });

        // Patch content
        await driveFetch(buildDriveUrl(`files/${file.id}`, { uploadType: "media" }), {
            method: "PATCH",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(data)
        });

        log(`✅ Genesis admin created: ${userEmail}`);
    }

    /* ================== STEP 3: DEVICE IDENTITY ================== */

    const IDENTITY_VERSION = 1;

    function identityStorageKey() {
        if (!userEmail) throw new Error("Identity requested before user email known");
        return `access4.identity::${userEmail}`;
    }

    /* Entry point */
    async function ensureIdentity() {
        log("Checking device identity");

        const stored = loadStoredIdentity();

        if (stored) {
            log("Existing identity found");
            await unlockExistingIdentity(stored);
        } else {
            log("No identity found on this device");
            await createNewIdentity();
        }

        log("✅ Device identity verified");
    }

    /* ---------- Storage ---------- */

    function loadStoredIdentity() {
        const raw = localStorage.getItem(identityStorageKey());
        if (!raw) return null;
        return JSON.parse(raw);
    }

    function saveIdentity(data) {
        localStorage.setItem(identityStorageKey(), JSON.stringify(data));
    }

    /* ---------- Password UI ---------- */

    async function promptForPassword(message) {
        const pwd = prompt(message);
        if (!pwd) throw new Error("Password required");
        return pwd;
    }

    /* ---------- Existing Identity ---------- */

    async function unlockExistingIdentity(identity) {
        const password = await promptForPassword("Enter your Access4 password");

        const aesKey = await deriveKeyFromPassword(
            password,
            identity.kdf.salt,
            identity.kdf.iterations
        );

        try {
            await decryptPrivateKey(identity.encryptedPrivateKey, aesKey);
            log("Identity unlocked successfully");
        } catch {
            throw new Error("Incorrect password for this device");
        }
    }

    /* ---------- New Identity ---------- */

    async function createNewIdentity() {
        const password = await promptForPassword("Create a password for this device");

        log("Generating identity key pair");

        const keyPair = await crypto.subtle.generateKey(
            {
                name: "RSA-OAEP",
                modulusLength: 2048,
                publicExponent: new Uint8Array([1, 0, 1]),
                hash: "SHA-256"
            },
            true,
            ["encrypt", "decrypt"]
        );

        const privateKeyRaw = await crypto.subtle.exportKey("pkcs8", keyPair.privateKey);
        const publicKeyRaw  = await crypto.subtle.exportKey("spki", keyPair.publicKey);

        const saltBytes = crypto.getRandomValues(new Uint8Array(16));
        const saltB64 = arrayBufferToBase64(saltBytes);
        const iterations = 100_000;

        const aesKey = await deriveKeyFromPassword(password, saltB64, iterations);
        const encryptedPrivateKey = await encryptPrivateKey(privateKeyRaw, aesKey);

        saveIdentity({
            version: IDENTITY_VERSION,
            encryptedPrivateKey,
            publicKey: arrayBufferToBase64(publicKeyRaw),
            kdf: {
                salt: saltB64,
                iterations
            }
        });

        log("New device identity created");
    }

    /* ---------- Crypto Helpers ---------- */

    async function deriveKeyFromPassword(password, saltB64, iterations) {
        const salt = base64ToArrayBuffer(saltB64);

        const keyMaterial = await crypto.subtle.importKey(
            "raw",
            new TextEncoder().encode(password),
            "PBKDF2",
            false,
            ["deriveKey"]
        );

        return crypto.subtle.deriveKey(
            {
                name: "PBKDF2",
                salt,
                iterations,
                hash: "SHA-256"
            },
            keyMaterial,
            { name: "AES-GCM", length: 256 },
            false,
            ["encrypt", "decrypt"]
        );
    }

    async function encryptPrivateKey(data, aesKey) {
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const cipher = await crypto.subtle.encrypt(
            { name: "AES-GCM", iv },
            aesKey,
            data
        );

        return {
            iv: arrayBufferToBase64(iv),
            data: arrayBufferToBase64(cipher)
        };
    }

    async function decryptPrivateKey(encrypted, aesKey) {
        const iv = base64ToArrayBuffer(encrypted.iv);
        const data = base64ToArrayBuffer(encrypted.data);

        return crypto.subtle.decrypt(
            { name: "AES-GCM", iv },
            aesKey,
            data
        );
    }

    /* ---------- Utils ---------- */

    function arrayBufferToBase64(buf) {
        return btoa(String.fromCharCode(...new Uint8Array(buf)));
    }

    function base64ToArrayBuffer(b64) {
        return Uint8Array.from(atob(b64), c => c.charCodeAt(0));
    }

    /* ================== STEP 4: ACCOUNT PUBLIC KEY ================== */

    const PUBKEY_FOLDER_NAME = "pub-keys";

    /* Entry point after identity verified */
    async function ensureAccountPublicKey() {
        log("Checking account public key in Drive");

        // 1️⃣ Find or create pub-keys folder under root
        const folderId = await findOrCreatePubKeysFolder();

        // 2️⃣ Check if pubkey file exists
        const filename = `${userEmail}.json`;
        const query = `'${folderId}' in parents and name='${filename}' and trashed=false`;
        const res = await driveFetch(buildDriveUrl("files", { q: query, fields: "files(id,name)" }));

        if (res.files.length > 0) {
            log("Account public key already exists in Drive");
            return res.files[0].id;
        }

        log("Account public key not found in Drive, creating...");

        const storedIdentity = loadStoredIdentity();
        if (!storedIdentity) throw new Error("Local identity missing");

        // 3️⃣ Prepare public key JSON
        const pubData = {
            email: userEmail,
            publicKey: storedIdentity.publicKey,
            created: storedIdentity.created || new Date().toISOString(),
            version: storedIdentity.version || 1
        };

        // 4️⃣ Multipart upload to create the file in Drive
        const boundary = '-------314159265358979323846';
        const body =
            `--${boundary}\r\n` +
            'Content-Type: application/json; charset=UTF-8\r\n\r\n' +
            JSON.stringify({ name: filename, parents: [folderId] }) + '\r\n' +
            `--${boundary}\r\n` +
            'Content-Type: application/json\r\n\r\n' +
            JSON.stringify(pubData) + '\r\n' +
            `--${boundary}--`;

        await fetch(`https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': `multipart/related; boundary=${boundary}`
            },
            body
        });

        log(`✅ Account public key uploaded for ${userEmail}`);
    }

    /* Helper: find or create pub-keys folder */
    async function findOrCreatePubKeysFolder() {
        const query = `'${ACCESS4_ROOT_ID}' in parents and name='${PUBKEY_FOLDER_NAME}' and mimeType='application/vnd.google-apps.folder' and trashed=false`;
        const res = await driveFetch(buildDriveUrl("files", { q: query, fields: "files(id,name)" }));

        if (res.files.length > 0) {
            log(`Pub-keys folder found: ${res.files[0].id}`);
            return res.files[0].id;
        }

        log("Pub-keys folder not found, creating...");
        const folder = await driveFetch(buildDriveUrl("files"), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                name: PUBKEY_FOLDER_NAME,
                mimeType: "application/vnd.google-apps.folder",
                parents: [ACCESS4_ROOT_ID]
            })
        });

        log(`Pub-keys folder created: ${folder.id}`);
        return folder.id;
    }




    /* ================== LOGOUT ================== */

    function logout() {
        accessToken = null;
        userEmail = null;
        document.getElementById("userEmail").textContent = "Not signed in";
        document.getElementById("signinBtn").disabled = false;
        document.getElementById("logoutBtn").disabled = true;
        log("Logged out");
    }

    /* ================== INIT ================== */

    window.onload = initGIS;

</script>
</body>
</html>
