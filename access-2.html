<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Signal-Style Google Drive Encryption Demo w/ GIS</title>
<style>
body { font-family: sans-serif; max-width: 800px; margin: auto; }
textarea, input { width: 100%; margin: 6px 0; }
button { margin: 6px 0; }
pre { background: #f4f4f4; padding: 10px; overflow-x: auto; }
#userEmail { font-weight: bold; }
</style>
<script
  src="https://accounts.google.com/gsi/client"
  async
  defer
  onload="initGIS()">
</script>

</head>
<body>

<h2>Signal-Style Google Drive Encryption w/ Google Sign-In</h2>

<div>
  Signed in as: <span id="userEmail">Not signed in</span>
  <button id="signinBtn">Sign in with Google</button>
  <button id="logoutBtn" disabled>Logout</button>
</div>

<label>Password (used to protect private key)</label>
<input id="password" type="password">

<label>Plaintext to encrypt</label>
<textarea id="plaintext">Hello Google Drive ??</textarea>

<button onclick="encryptAndUpload()">Encrypt & Upload</button>

<hr>

<label>Google Drive File ID to Download</label>
<input id="fileId">

<button onclick="downloadAndDecrypt()">Download & Decrypt</button>

<h3>Output</h3>
<pre id="output"></pre>

<script>
const encoder = new TextEncoder();
const decoder = new TextDecoder();
let accessToken = null;
let userEmail = null;
let tokenClient = null;
const allowedEmails = ["myemailinbox1234@gmail.com", "anilrpinto1@gmail.com"];

function log(msg) {
  document.getElementById("output").textContent += msg + "\n";
}

// ------------------ Google Identity Services Setup ------------------
function initGIS() {
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: "738922366916-ppn1c24mp9qamr6pdmjqss3cqjmvqljv.apps.googleusercontent.com",
    scope: "https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.email",
    callback: (resp) => {
      accessToken = resp.access_token;
      fetchUserEmail();
      document.getElementById("signinBtn").disabled = true;
      document.getElementById("logoutBtn").disabled = false;
      log("Signed in successfully.");
    }
  });
}

async function fetchUserEmail() {
  const res = await fetch("https://www.googleapis.com/oauth2/v3/userinfo", {
    headers: { Authorization: `Bearer ${accessToken}` }
  });
  const data = await res.json();
  userEmail = data.email;
  document.getElementById("userEmail").textContent = userEmail;

  if (allowedEmails && !allowedEmails.includes(userEmail)) {
    alert("Email not allowed!");
    logout();
  }
}

function signIn() {
  tokenClient.requestAccessToken({ prompt: "consent" });
}

function silentRefresh() {
  if (accessToken) tokenClient.requestAccessToken({ prompt: "" });
}

function logout() {
  accessToken = null;
  userEmail = null;
  document.getElementById("userEmail").textContent = "Not signed in";
  document.getElementById("signinBtn").disabled = false;
  document.getElementById("logoutBtn").disabled = true;
  localStorage.removeItem("identity");
  localStorage.removeItem("publicKey");
  log("Logged out and cleared local identity.");
}

document.getElementById("signinBtn").onclick = signIn;
document.getElementById("logoutBtn").onclick = logout;

setInterval(silentRefresh, 50*60*1000); // refresh every 50 min

// ------------------ Crypto Utilities ------------------
function b64(buf) { return btoa(String.fromCharCode(...new Uint8Array(buf))); }
function fromB64(str) { return Uint8Array.from(atob(str), c => c.charCodeAt(0)); }

async function deriveKey(password, salt) {
  const base = await crypto.subtle.importKey(
    "raw", encoder.encode(password), "PBKDF2", false, ["deriveKey"]
  );
  return crypto.subtle.deriveKey(
    { name: "PBKDF2", salt, iterations: 250000, hash: "SHA-256" },
    base,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt","decrypt"]
  );
}

// ------------------ Identity Key Management ------------------
async function createIdentity(password) {
  const pair = await crypto.subtle.generateKey(
    { name:"RSA-OAEP", modulusLength:2048, publicExponent:new Uint8Array([1,0,1]), hash:"SHA-256" },
    true,
    ["encrypt","decrypt"]
  );
  const pkcs8 = await crypto.subtle.exportKey("pkcs8", pair.privateKey);
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const key = await deriveKey(password, salt);
  const encrypted = await crypto.subtle.encrypt({ name:"AES-GCM", iv }, key, pkcs8);
  localStorage.setItem("identity", JSON.stringify({ salt:b64(salt), iv:b64(iv), encrypted:b64(encrypted) }));
  localStorage.setItem("publicKey", b64(await crypto.subtle.exportKey("spki", pair.publicKey)));
  return pair;
}

async function loadPrivateKey(password) {
  const stored = JSON.parse(localStorage.getItem("identity"));
  const salt = fromB64(stored.salt);
  const iv = fromB64(stored.iv);
  const encrypted = fromB64(stored.encrypted);
  const key = await deriveKey(password, salt);
  const pkcs8 = await crypto.subtle.decrypt({name:"AES-GCM",iv}, key, encrypted);
  return crypto.subtle.importKey("pkcs8", pkcs8, { name:"RSA-OAEP", hash:"SHA-256" }, false, ["decrypt"]);
}

async function loadPublicKey() {
  return crypto.subtle.importKey("spki", fromB64(localStorage.getItem("publicKey")), { name:"RSA-OAEP", hash:"SHA-256" }, false, ["encrypt"]);
}

// ------------------ Encrypt & Upload ------------------
async function encryptAndUpload() {
  if (!accessToken) { alert("Sign in first!"); return; }
  const password = document.getElementById("password").value;
  const text = document.getElementById("plaintext").value;

  log("Starting encryption…");
  if (!localStorage.getItem("identity")) {
    log("Creating identity key…");
    await createIdentity(password);
  }
  const publicKey = await loadPublicKey();
  const fileKey = await crypto.subtle.generateKey({ name:"AES-GCM", length:256 }, true, ["encrypt","decrypt"]);
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ciphertext = await crypto.subtle.encrypt({ name:"AES-GCM", iv }, fileKey, encoder.encode(text));

  // RSA encrypt raw AES key (wrap)
  const rawFileKey = await crypto.subtle.exportKey("raw", fileKey);
  const wrappedKey = await crypto.subtle.encrypt({ name:"RSA-OAEP" }, publicKey, rawFileKey);

  const envelope = { iv:b64(iv), wrappedKey:b64(wrappedKey), ciphertext:b64(ciphertext) };

  // Upload to Drive
  const form = new FormData();
  form.append("metadata", new Blob([JSON.stringify({ name:"encrypted-envelope.json", mimeType:"application/json" })], { type:"application/json" }));
  form.append("file", new Blob([JSON.stringify(envelope)], { type:"application/json" }));

  try {
    const res = await fetch("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart", {
      method:"POST", headers:{Authorization:`Bearer ${accessToken}`}, body:form
    });
    const responseText = await res.text();
    if (!res.ok) { log("Upload failed:"); log(responseText); return; }
    const json = JSON.parse(responseText);
    log("Uploaded File ID: " + json.id);
  } catch(e) { log("Upload error: "+e); }
}

// ------------------ Download & Decrypt ------------------
async function downloadAndDecrypt() {
  if (!accessToken) { alert("Sign in first!"); return; }
  const password = document.getElementById("password").value;
  const fileId = document.getElementById("fileId").value;
  if (!fileId) { alert("Enter File ID!"); return; }

  try {
    const res = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, { headers:{Authorization:`Bearer ${accessToken}`} });
    if (!res.ok) { log("Download failed: " + await res.text()); return; }
    const envelope = await res.json();
    const privateKey = await loadPrivateKey(password);

    // RSA decrypt ? AES raw key
    const rawFileKey = await crypto.subtle.decrypt({ name:"RSA-OAEP" }, privateKey, fromB64(envelope.wrappedKey));
    const fileKey = await crypto.subtle.importKey("raw", rawFileKey, { name:"AES-GCM", length:256 }, false, ["decrypt"]);

    const plaintext = await crypto.subtle.decrypt({ name:"AES-GCM", iv:fromB64(envelope.iv) }, fileKey, fromB64(envelope.ciphertext));
    log("Decrypted text:\n" + decoder.decode(plaintext));
  } catch(e) { log("Decryption error: "+e); }
}
</script>
</body>
</html>

